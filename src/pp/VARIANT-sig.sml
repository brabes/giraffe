signature VARIANT =
  sig
    (**
     * The type `version` represents a version that has the properties
     * described in the signature VERSION.
     *)
    type version
    structure Version : VERSION where type version = version

    (**
     * The type `'a t` represents variants of a value of type `'a`.  There
     * are zero or more variant values identified by a version and there is a
     * default value.  A variant with version `v` applies to versions up to
     * and including `v` that are not applicable to earlier variants.  The
     * default applies to versions not applicable to any variants.
     *
     * Therefore, in a variant `var : 'a t`, each value applies to a range of
     * versions greater than lb and not greater than ub, written (lb, ub],
     * where lb is a lower bound that is either a version in `var` or
     * unbounded below and ub is an upper bound that is either a version in
     * `var` or unbounded above.
     *
     * The rationale for specifying the last version in a range, as opposed
     * to the first, is to support the scenario where upstream changes on the
     * main development branch of the versioned item require a new variant
     * before the next release is made.  The version of the next release is
     * not generally known in advance so the first version for the new
     * variant cannot be specified.  The last version for the previous
     * variant can be specified as is the most recent release.  Therefore
     * variants are specified using the last version in a range.
     *)
    type 'a t

    (**
     * `default d` creates a variant containing only default value `d`.
     *
     * `variant (vxs, d)` creates a variant with
     *   - value `x` for version `v`, for each `(v, x)` in `vxs`, and
     *   - default value `d`.
     *)
    val default : 'a -> 'a t
    val variant : (version * 'a) list * 'a -> 'a t

    (**
     * `versions var` returns the versions of the variants in `var` in
     * ascending order.
     *
     * `values var` returns all values of the variant `var`.  The list of
     * variant values is in ascending version order.  There is no
     * guarantee that `values o variant` is the identity function.
     *
     * `value (SOME ver) var` returns the value of `var` for version `ver`.
     * Note that `ver` does not need to be a version in `versions var`.
     * `value NONE var` returns the default value of `var`.
     *)
    val versions : 'a t -> version list
    val values : 'a t -> (version * 'a) list * 'a
    val value : version option -> 'a t -> 'a

    (**
     * Values for consecutive versions in variants generated by operations
     * may be equal.  If equal, they can be merged (as the later version) for
     * efficiency.  There is no need to merge equal consecutive versions and
     * it would not be worthwhile if the test is expensive.  Operations that
     * generate a variant are parameterized by a function that tests the
     * 'same'-ness of two values.  If the test is true, the values are the
     * same and, therefore, equal so will be merged.  If the test is false,
     * the values are not the same, even though they may be equal, and will
     * not be merged.  Any conservative equality test can be used for a
     * 'same'-ness test of a variant's values, e.g.
     *   - `fn _ => false` to always assume values are not the same;
     *   - `op =` to use the built-in equality test (which will constrain
     *      the type of the variant's values to have an equality type).
     *
     * The type `'a same` is an abbreviation for the type of a 'same'-ness
     * test on values of type `'a`.
     *)
    type 'a same = 'a * 'a -> bool

    (**
     * `split (same1, same2) var` splits the variant of pair values `var`
     * into the pair of variants `(var1', var2')` each containing the
     * corresponding pair values from `var`.  `same1` and `same2` are used
     * to check whether consecutive versions have the same value in `var1'`
     * and `var2'`, respectively, which are merged.
     *
     * `join same (var1, var2)` combines the pair of variants `(var1, var2)`
     * into a variant of pair values `var'`.  `same` is used to check whether
     * consecutive versions have the same value in `var'`, which are merged.
     * `join` can be defined in terms of `map2`, specified below, as follows:
     *
     *   fun join same = map2 same unboundedFrame (fn _ => default)
     * 
     * but is provided for convenience.
     *)
    val split : 'a same * 'b same -> ('a * 'b) t -> 'a t * 'b t
    val join : ('a * 'b) same -> 'a t * 'b t -> ('a * 'b) t

    (**
     * The functions `map`, `fold` and `foldmap` map or fold a function that
     * cannot introduce new variants.  A fold is performed independently
     * on each variant value so a fold is a special case of a map, but
     * fold functions are provided for convenience.
     *
     * For each value `b` in `bvar` that applies to versions in the range
     * (lb, ub], `map asame f bvar` evaluates `f b` to give the value for
     * the range (lb, ub] in the result.  `asame` is used to check for
     * consecutive versions with the same value in the result, which are
     * merged.
     *
     * For each value `a` in `avar` that applies to versions in the range
     * (lb, ub], `fold asame f (b, avar)` evaluates `f (b, a)` to give the
     * value for the range (lb, ub] in the result.  `asame` is used to check
     * for consecutive versions with the same value in the result, which are
     * merged.

     * For each value `a` in `avar` that applies to versions in the range
     * (lb, ub], `foldmap (asame, csame) f (b, avar)` evaluates `f (b, a)` to
     * give (c', a') where `c'` gives the value for the range (lb, ub] in
     * `cvar'` and `a'` gives the value for the range (lb, ub] in `avar'` and
     * the result is `(cvar', avar')`.  `asame` and `csame` are used to check
     * for consecutive versions with the same value in `avar'` and `cvar'`,
     * respectively, which are merged.  `foldmap` can be defined in terms of
     * `fold` as follows:
     *
     *   fun foldmap (asame, csame) f =
     *     let
     *       fun notSame _ = false                  (* see note 1 below *)
     *     in
     *       split (csame, asame) o fold notSame f
     *     end
     *
     * Notes
     *
     *  1  The check for consecutive versions with the same value must be
     *     performed by `split` because it checks the variants of unpaired
     *     values individually.  Therefore there is no need for the check to
     *     be performed earlier on pair values, so the function `notSame` is
     *     used which always returns `false`.
     *)
    val map :   'a same ->      ('b ->      'a) ->      'b t -> 'a t
    val fold :  'a same -> ('b * 'a ->      'a) -> 'b * 'a t -> 'a t
    val foldmap :
      'a same * 'c same -> ('b * 'a -> 'c * 'a) -> 'b * 'a t -> 'c t * 'a t

    (**
     * The functions `map1`, `map2`, `fold1` and `foldmap1` map or fold a
     * function `f` that can introduce new variants.  For efficiency, these
     * functions have a frame argument that restricts the values that `f`
     * is evaluated on.  The function `f` has a frame argument and `f frame`
     * should pass the frame to any function in its implementation that takes
     * a frame.  `unboundedFrame` is the initial value for a frame outside
     * the scope of an existing frame.  Using `unboundedFrame` in the scope
     * of an existing frame could result in unnecessary evaluation.
     *)
    type frame
    val unboundedFrame : frame

    (**
     * The functions `map1`, `map2`, `fold1` and `foldmap1` map or fold a
     * function `f` that can introduce new variants.  A fold is performed
     * independently on each variant value so a fold is a special case of a
     * map, but fold functions are provided for convenience.
     *
     * For each value `b` in `bvar` that applies to versions in the range
     * (lb, ub], `map1 asame frame f bvar` evaluates `f frame b` to give
     * the values for the range (lb, ub] in the result.  `asame` is used to
     * check for consecutive versions with the same value in the result,
     * which are merged.
     *
     * For each possible combination of value `b` in `bvar` and value `c` in
     * `cvar` that applies to versions in the range (lb, ub],
     * `map2 asame frame f (bvar, cvar)` evaluates `f frame (b, c)` to give
     * the values for the range (lb, ub] in the result.  `asame` is used to
     * check for consecutive versions with the same value in the result,
     * which are merged.
     *
     * For each possible combination of value `b` in `bvar` and values
     * `avar1` in `avar` that applies to versions in the range (lb, ub],
     * `fold1 asame frame f (bvar, avar)` evaluates `f frame (b, avar1)` to
     * give the values for the range (lb, ub] in the result.  `asame` is used
     * to check for consecutive versions with the same value in the result,
     * which are merged.  This is special case of considering each possible
     * combination of value `b` in `bvar` and value `a` in `avar` and
     * evaluating `f frame (b, default a)`, so `fold1` can be defined in
     * terms of `map2` as follows:
     *
     *   fun fold1 same frame f =
     *     let
     *       fun f' frame (b, a) = f frame (b, default a)
     *     in
     *       map2 same frame f'
     *     end
     *
     * However, this may not be the most efficient implementation because
     * `f frame` is always called with a default-only accumulator value.  The
     * restricted type of `fold1` allows fewer evaluations of `f` by allowing
     * many variants in `avar1`.
     *
     * For each possible combination of value `b` in `bvar` and values
     * `avar1` in `avar` that applies to versions in the range (lb, ub],
     * `fold2 (asame, csame) frame f (bvar, avar)` evaluates
     * `f frame (b, avar1)` to give (cvar1', avar1') where `cvar1'` gives the
     * values for the range (lb, ub] in `cvar'` and `avar1'` gives the values
     * for the range (lb, ub] in `avar'` and the result is `(cvar', avar')`.
     * `asame` and `csame` are used to check for consecutive versions with
     * the same value in `avar'` and `cvar'`, respectively, which are merged.
     * `foldmap1` can be defined in terms of `fold1` as follows:
     *
     *   fun foldmap1 (asame, csame) frame f =
     *     let
     *       fun notSame _ = false                  (* see note 1 below *)
     *       fun f' frame = join notSame o f frame  (* see note 2 below *)
     *     in
     *       split (csame, asame) o fold1 notSame frame f'
     *     end
     *
     * Notes
     *
     *  1  The check for consecutive versions with the same value must be
     *     performed by `split` because it checks the variants of unpaired
     *     values individually.  Therefore there is no need for the check to
     *     be performed earlier on pair values, so the function `notSame` is
     *     used which always returns `false`.
     *
     *  2  Although `join` uses `unboundedFrame`, its use in `f'` is fine
     *     because its overhead is minimal and `fold1` performs a frame check
     *     on the result of `f'` anyway.
     *)
    val map1  : 'a same -> frame -> (frame -> 'b        -> 'a t) -> 'b t        -> 'a t
    val map2  : 'a same -> frame -> (frame -> 'b * 'c   -> 'a t) -> 'b t * 'c t -> 'a t
    val fold1 : 'a same -> frame -> (frame -> 'b * 'a t -> 'a t) -> 'b t * 'a t -> 'a t
    val foldmap1 :
      'a same * 'c same
       -> frame -> (frame -> 'b * 'a t -> 'c t * 'a t) -> 'b t * 'a t -> 'c t * 'a t

    (**
     * List functions are provided for short-circuit behaviour.
     *)
    structure List :
      sig
        val all : frame -> (frame -> 'a -> bool t) -> 'a list -> bool t
      end
  end

