=Object=

Context

  repo
    the repository in use

  objectInfo
    the object typelib info


Placeholders

  ObjectName = GIBaseInfo.getName objectInfo

  ObjectNamespace = GIBaseInfo.getNamespace objectInfo

  ObjectCPrefix = GIRepository.getCPrefix repo <ObjectNamespace>

  getTypeSymbol = GIObjectInfo.getTypeInit objectInfo


Conditions

  isGObject = "GObject" = ObjectNamespace

  isParentNamespace = ParentObjectNamespace = ObjectNamespace


==Root class signature==



==Root class structure==



==Derived class signature==

signature <OBJECT_NAMESPACE>_<OBJECT_NAME>_CLASS =
  sig
    type 'a <object_name>
                                                               -.
    type 'a <parent_object_name>_class                          |
    include CLASS                                               | isParentNamespace
      where type 'a class = 'a <object_name> <parent_object_name>_class
                                                               -'
                                                               -.
    include CLASS                                               | not isParentNamespace
      where type 'a class = 'a <object_name> <ParentObjectNamespace>.<ParentObjectName>Class.class
                                                               -'
                                                                    -.
    type ('a, 'b) value_accessor_t                                   |
    val t : (base class, 'a class) value_accessor_t                  | isGObject
    val tOpt : (base class option, 'a class option) value_accessor_t |
                                                                    -'
                                                                    -.
    val t : (base class, 'a class) ValueAccessor.t                   | not isGObject
    val tOpt : (base class option, 'a class option) ValueAccessor.t  |
                                                                    -'
  end


==Derived class structure==

structure <ObjectNamespace><ObjectName>Class :>
  <OBJECT_NAMESPACE>_<OBJECT_NAME>_CLASS
                                                               -.
    where                                                       |
      type 'a <parent_object_name>_class =                      | isParentNamespace
        'a <ParentObjectNamespace><ParentObjectName>Class.class |
                                                               -'
                                                                          -.
    where type ('a, 'b) value_accessor_t = ('a, 'b) ValueAccessor.t        | isGObject
                                                                          -'
    where type C.notnull = <ParentObjectNamespace><ParentObjectName>Class.C.notnull
    where type 'a C.p = 'a <ParentObjectNamespace><ParentObjectName>Class.C.p =
  struct
                                                               -.
    type 'a <parent_object_name>_class =                        |
      'a <ParentObjectNamespace><ParentObjectName>Class.class   | isParentNamespace
                                                               -'
    open <ParentObjectNamespace><ParentObjectName>Class
    type 'a <objectname> = unit
    type 'a class = 'a <object_name> class
  end


==Object signature==

signature <OBJECT_NAMESPACE>_<OBJECT_NAME> =
  sig
    (* Local Types *)

    type 'a class

    type <varlist[1]> <local_name[1]>

    ...

    type <varlist[N]> <local_name[N]>
                                                            -.
    type 'a signal_t                                         | isGObject and S > 0
                                                            -'
                                                            -.
    type ('object, 'a) property_readonly                     |
    type ('object, 'a) property_writeonly                    | isGObject and P > 0
    type ('object, 'a, 'b) property_readwrite                |
                                                            -'

    (* Type Abbreviations *)

    type t = base class


    (* Interfaces *)

    <InterfaceConvSpec[1]>

    ...

    <InterfaceConvSpec[I]>


    (* Constants *)

    <ConstantSpec[1]>

    ...

    <ConstantSpec[C]>


    (* Functions *)
                                                          -.
    val getType : unit -> <type>                           | getTypeSymbol <> "intern"
                                                          -'
    <FunctionSpec[1]>

    ...

    <FunctionSpec[M]>


    (* Signals *)

    <SignalSpec[1]>

    ...

    <SignalSpec[S]>


    (* Properties *)

    <PropertySpec[1]>

    ...

    <PropertySpec[P]>
  end


where


  type
    is defined as follows:

        GObject.Type.t
          if not isGObject

        type_t
          if isGObject


  localName[n], typeName[n], t[n], varlist[n]
    For n in 1 .. N

      <varlist[n]> <local_name[n]>

    is the <n>th element in the list of types referenced later in the
    signature that, for some InterfaceName and some var,
    has one of the following forms:

      <var> <interface_name>_class
      <var> <interface_name>_union
      <interface_name>_t

    where the corresponding global type has the form

      <ObjectNamespace>.<TypeName[n]>.<t[n]>


==Object structure==

structure <ObjectNamespace><ObjectName> :>
  <OBJECT_NAMESPACE>_<OBJECT_NAME>
    where type 'a class = 'a <ObjectNamespace><ObjectName>Class.class

    where type <varlist[1]> <local_name[1]> = <varlist[1]> <ObjectNamespace><TypeName[1]>.<t[1]>

    ...

    where type <varlist[N]> <local_name[N]> = <varlist[N]> <ObjectNamespace><TypeName[N]>.<t[N]>
                                                                                          -.
    where type 'a signal_t = 'a Signal.t                                                   | isGObject and S > 0
                                                                                          -'
                                                                                          -.
    where type ('object, 'a) property_readonly = ('object, 'a) Property.readonly           |
    where type ('object, 'a) property_writeonly = ('object, 'a) Property.writeonly         | isGObject and P > 0
    where type ('object, 'a, 'b) property_readwrite = ('object, 'a, 'b) Property.readwrite |
                                                                                          -'
=
  struct
    (* Low-Level Functions *)
                                                                            -.
    local                                                                    |
      open PolyMLFFI                                                         |
    in                                                                       |
      val getType_ =                                                         |
        call                                                                 |
          (getSymbol "<getTypeSymbol>")                                      |
          (cVoid --> GObjectType.PolyML.cVal);                               |
                                                                             | Poly/ML only
      <LowLevelFunction[1]>                                                  |
                                                                             |
      ...                                                                    |
                                                                             |
      <LowLevelFunction[M]>                                                  |
    end                                                                      |
                                                                            -'
                                                                            -.
    val getType_ = _import "<getTypeSymbol>" : unit -> GObjectType.C.val_;   |
                                                                             |
    <LowLevelFunction[1]>                                                    |
                                                                             | MLton only
    ...                                                                      |
                                                                             |
    <LowLevelFunction[M]>                                                    |
                                                                            -'

    (* Local Types *)

    type 'a class = 'a <ObjectNamespace><ObjectName>Class.class

    type <varlist[1]> <local_name[1]> = <varlist[1]> <ObjectNamespace><TypeName[1]>.<t[1]>

    ...

    type <varlist[N]> <local_name[N]> = <varlist[N]> <ObjectNamespace><TypeName[N]>.<t[N]>
                                                                                          -.
    type 'a signal_t = 'a Signal.t                                                         | isGObject and S > 0
                                                                                          -'
                                                                                          -.
    type ('object, 'a) property_readonly = ('object, 'a) Property.readonly                 |
    type ('object, 'a) property_writeonly = ('object, 'a) Property.writeonly               | isGObject and P > 0
    type ('object, 'a, 'b) property_readwrite = ('object, 'a, 'b) Property.readwrite       |
                                                                                          -'

    (* Type Abbreviations *)

    type t = base class


    (* Interfaces *)

    <InterfaceConvDec[1]>

    ...

    <InterfaceConvDec[I]>


    (* Constants *)

    <ConstantDec[1]>

    ...

    <ConstantDec[C]>


    (* High-Level Functions *)
                                                          -.
    val getType = (I ---> GObjectType.C.fromVal) getType_  | getTypeSymbol <> "intern"
                                                          -'
    <HighLevelFunction[1]>

    ...

    <HighLevelFunction[M]>


    (* Signals *)

    local
      open ClosureMarshal Signal
    in
      <SignalDec[1]>
      ...
      <SignalDec[S]>
    end


    (* Properties *)

    local
      open Property
    in
      <PropertyDec[1]>
      ...
      <PropertyDec[P]>
    end
  end


where


  localName[n], typeName[n], t[n], varlist[n] are the same as for the signature;


  ...



