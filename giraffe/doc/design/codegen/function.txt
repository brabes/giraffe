=Function=

Context

  repo
    the repository in use

  optContainerInfo
    typelib info of the container of the function, if any
    (NONE indicates namespace-level function)

  functionInfo
    typelib info of the function


Placeholders

  optContainerName = Option.map GIRepository.BaseInfo.getName optContainerInfo

  FunctionName = GIRepository.BaseInfo.getName functionInfo

  FunctionSymbol = GIRepository.FunctionInfo.getSymbol functionInfo

  FunctionNamespace = GIRepository.BaseInfo.getNamespace functionInfo

  FunctionFlags = GIRepository.FunctionInfo.getFlags functionInfo


Conditions

  isValueRecord(structInfo)
    indicates whether structName and structNamespace have been identified as a
    value-like record in the configuration where

      structName      = getName structInfo
      structNamespace = BaseInfo.getNamespace structInfo



==Common==

The type of a non-nested array may indicate that it is zero-terminated and has
a length parameter.  In this case, the abstract representation is zero-terminated
depending on whether the array is passed to the function (via an IN or INOUT
parameter) or not (via an OUT parameter or the return value).  Therefore,
ArrayStructId depends on a flag isOutParOrRet.  A nested array cannot depend
on a length parameter so the flag is optional and is NONE for a nested array.


  ArrayStructId(arrayTypeInfo, isOutParOrRet)
    is as follows:

      elemTypeInfo = GIRepository.TypeInfo.getParamType arrayTypeInfo 0

      <ElemStructId(elemTypeInfo)><ArrayType(arrayTypeInfo, isOutParOrRet)>


  ArrayType(arrayTypeInfo, isOutParOrRet)
    is

      C<Ptr>Array<N>

    where

      N is as follows:

        isZeroTerminated = GIRepository.TypeInfo.isZeroTerminated arrayTypeInfo
        arrayLengthParamIdx = GIRepository.TypeInfo.getArrayLength arrayTypeInfo
        arraySize = GIRepository.TypeInfo.getArrayFixedSize arrayTypeInfo

          isZeroTerminated    arrayLengthParamIdx     arraySize      optOutParOrRet      | N
        =================================================================================+=========================
          _                   _                       <n>, n <> ~1   _                   | N
        ---------------------------------------------------------------------------------+-------------------------
          false               <i>, i <> ~1            ~1             _                   | N
        ---------------------------------------------------------------------------------+-------------------------
          false               ~1                      ~1             _                   | <raise Error "cannot determine array length">
        ---------------------------------------------------------------------------------+-------------------------
          true                <i>, i <> ~1            ~1             SOME false          | N
        ---------------------------------------------------------------------------------+-------------------------
          true                <i>, i <> ~1            ~1             NONE | SOME true    | <>
        ---------------------------------------------------------------------------------+-------------------------
          true                ~1                      ~1             _                   | <>
        ---------------------------------------------------------------------------------+-------------------------


      Ptr is as follows:

        elemTypeInfo = GIRepository.TypeInfo.getParamType arrayTypeInfo 0

          isPointer(elemTypeInfo)     | Ptr
        ==============================+===================
          false                       | <>
        ------------------------------+-------------------
          true                        | Ptr
        ------------------------------+-------------------


  ElemStructId(typeInfo)
    is as follows:

      tag          = GIRepository.TypeInfo.getTag typeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    Utf8
        ARRAY     --->    <ArrayStructId(typeInfo, isOutParOrRet)>
        GLIST     --->    <raise Error "not expected">
        GSLIST    --->    <raise Error "not expected">
        GHASH     --->    <raise Error "not expected">
        VOID      --->    <raise Error "not expected">
        BOOLEAN   --->    GBool
        CHAR      --->    GChar
        UCHAR     --->    GUChar
        INT       --->    GInt
        UINT      --->    GUInt
        SHORT     --->    GShort
        USHORT    --->    GUShort
        LONG      --->    GLong
        ULONG     --->    GULong
        INT8      --->    GInt8
        UINT8     --->    GUInt8
        INT16     --->    GInt16
        UINT16    --->    GUInt16
        INT32     --->    GInt32
        UINT32    --->    GUInt32
        INT64     --->    GInt64
        UINT64    --->    GUInt64
        FLOAT     --->    GFloat
        DOUBLE    --->    GDouble
        SSIZE     --->    GSSize
        SIZE      --->    GSize
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    Utf8
        UNICHAR   --->    GChar
        INTERFACE --->    <InterfaceElemStructId>

    where

      InterfaceElemStructId is as follows:

        interfaceTypeInfo = GIRepository.TypeInfo.getInterface elemTypeInfo

        InterfaceName = GIRepository.BaseInfo.getName interfaceTypeInfo
        InterfaceNamespace = GIRepository.BaseInfo.getNamespace interfaceTypeInfo
        InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

        infoType = GIRepository.InfoType.getType interfaceTypeInfo
        isClass = infoType is OBJECT _ | INTERFACE _
        isRecord = infoType is STRUCT _
        isUnion = infoType is UNION _
        isEnum = infoType is ENUM _
        isFlags = infoType is FLAGS _
        isOther = not (isClass or isRecord or isUnion or isEnum or isFlags)

        isGlobal = InterfaceNamespace <> FunctionNamespace
        isNamespace = optContainerName = NONE
        isSelf = SOME InterfaceName = optContainerName


        <InterfaceNamespace><InterfaceName>Class
          if isGlobal and isClass

        <InterfaceNamespace><InterfaceName>Record
          if isGlobal and isRecord

        <InterfaceNamespace><InterfaceName>
          if isGlobal and isUnion

        <InterfaceNamespace><InterfaceName>
          if isGlobal and isEnum

        <InterfaceNamespace><InterfaceName>
          if isGlobal and isFlags

        <InterfaceNamespace><InterfaceName>
          if isGlobal and isOther


        <InterfaceNamespace><InterfaceName>Class
          if not isGlobal and isNamespace and isClass

        <InterfaceNamespace><InterfaceName>Record
          if not isGlobal and isNamespace and isRecord

        <InterfaceNamespace><InterfaceName>
          if not isGlobal and isNamespace and isUnion

        <InterfaceNamespace><InterfaceName>
          if not isGlobal and isNamespace and isEnum

        <InterfaceNamespace><InterfaceName>
          if not isGlobal and isNamespace and isFlags

        <InterfaceNamespace><InterfaceName>
          if not isGlobal and isNamespace and isOther


        <InterfaceNamespace><InterfaceName>Class
          if not isGlobal and not isNamespace and not isSelf and isClass

        <InterfaceNamespace><InterfaceName>Record
          if not isGlobal and not isNamespace and not isSelf and isRecord

        <InterfaceNamespace><InterfaceName>
          if not isGlobal and not isNamespace and not isSelf and isUnion

        <InterfaceNamespace><InterfaceName>
          if not isGlobal and not isNamespace and not isSelf and isEnum

        <InterfaceNamespace><InterfaceName>
          if not isGlobal and not isNamespace and not isSelf and isFlags

        <InterfaceNamespace><InterfaceName>
          if not isGlobal and not isNamespace and not isSelf and isOther


        <InterfaceNamespace><InterfaceName>Class
          if not isGlobal and not isNamespace and isSelf and isClass

        <InterfaceNamespace><InterfaceName>Record
          if not isGlobal and not isNamespace and isSelf and isRecord

        <>
          if not isGlobal and not isNamespace and isSelf and isUnion

        <>
          if not isGlobal and not isNamespace and isSelf and isEnum

        <>
          if not isGlobal and not isNamespace and isSelf and isFlags

        <>
          if not isGlobal and not isNamespace and isSelf and isOther


  isPointer(typeInfo)
    is defined as follows:

      tag = GIRepository.TypeInfo.getTag typeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    true
        ARRAY     --->    true
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    <raise Error "not expected">
        BOOLEAN   --->    false
        CHAR      --->    false
        UCHAR     --->    false
        INT       --->    false
        UINT      --->    false
        SHORT     --->    false
        USHORT    --->    false
        LONG      --->    false
        ULONG     --->    false
        INT8      --->    false
        UINT8     --->    false
        INT16     --->    false
        UINT16    --->    false
        INT32     --->    false
        UINT32    --->    false
        INT64     --->    false
        UINT64    --->    false
        FLOAT     --->    false
        DOUBLE    --->    false
        SSIZE     --->    false
        SIZE      --->    false
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    true
        UNICHAR   --->    false
        INTERFACE --->    isInterfacePointer(typeInfo)


  isInterfacePointer(interfaceTypeInfo)
    is defined as follows:

    infoType = GIRepository.InfoType.getType interfaceTypeInfo

    Conversion from infoType is as follows:

      false
        if infoType is FLAGS _ | ENUM _

      isValueRecord(structInfo)
        if infoType is STRUCT structInfo

      true
        otherwise



==Specification==

For
  L non-VOID non-length IN/INOUT parameters,
  K non-VOID non-length INOUT/OUT parameters,
FunctionSpec has the form as described below,
where a length parameter is one that provides the length of a C array in another parameter
or the return value, provided that the length parameter and the C array parameter have the
same direction or the length parameter for a C array return value has direction OUT.

Note that an IN parameter that provides the initial length of a C array OUT parameter or
return value is not considered to be a 'length' parameter above and, therefore, must be provided
by the caller.


  val <functionName> : <selfType> -> <inParamType[1]> * ... * <inParamType[L]> -> <retExpType>

    if K > 0 and anySet (FunctionFlags, IS_METHOD)


  val <functionName> : <inParamType[1]> * ... * <inParamType[L]> -> <retExpType>

    if K > 0 and L > 0 and not anySet (FunctionFlags, IS_METHOD)


  val <functionName> : unit -> <retExpType>

    if K > 0 and L = 0 and not anySet (FunctionFlags, IS_METHOD)


  val <functionName> : <selfType> -> <inParamType[1]> * ... * <inParamType[L]> -> <retValType>

    if K = 0 and anySet (FunctionFlags, IS_METHOD)


  val <functionName> : <inParamType[1]> * ... * <inParamType[L]> -> <retValType>

    if K = 0 and L > 0 and not anySet (FunctionFlags, IS_METHOD)


  val <functionName> : unit -> <retValType>

    if K = 0 and L = 0 and not anySet (FunctionFlags, IS_METHOD)


where


  retValType
    is the SML type representing the return type of the function
    translated as follows:

      mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo
      typeInfo      = GIRepository.CallableInfo.getReturnType functionInfo

        mayReturnNull    | retValType
      ===================+===================
        false            | <type(typeInfo, true)>
      -------------------+-------------------
        true             | <type(typeInfo, true)> option
      -------------------+-------------------


  retExpType
    when K > 0, taking the numer of conditional outputs to be KA, where
    the indices of conditional outputs are ka[1], ..., ka[KA] and the
    indices of non-conditional outputs are kb[1], ..., kb[K - KA], is
    defined as follows:

        retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
        tag         = GIRepository.TypeInfo.getTag retTypeInfo
        throws      = anySet (FunctionFlags, THROWS)

          tag     throws  0 < KA  KA < K   | retExpType
        ===================================+===================================================
          VOID    _       false   _        |
          VOID    true    _       _        | <outParamType[1]> * ... * <outParamType[K]>
          BOOLEAN true    _       _        |
        -----------------------------------+---------------------------------------------------
          _       _       false   _        | <retValType>
          _       true    _       _        |   * <outParamType[1]> * ... * <outParamType[K]>
        -----------------------------------+---------------------------------------------------
          BOOLEAN false   true    false    | (<outParamType[1]>
                                           |    * ...
                                           |    * <outParamType[KA]>) option
        -----------------------------------+---------------------------------------------------
          BOOLEAN false   true    true     | (<outParamType[ka[1]]>
                                           |    * ...
                                           |    * <outParamType[ka[KA]]>) option
                                           |   * <outParamType[kb[1]]>
                                           |   * ...
                                           |   * <outParamType[kb[K - KA]]>
        -----------------------------------+---------------------------------------------------
          _       false   true    _        | <raise Error>                         (see note 1)
        -----------------------------------+---------------------------------------------------

    This logic is applied to prevent unknown/arbitrary/uninitialized out
    parameter values (especially pointers and caller-allocated structures)
    being returned to the application by using an option type for
    conditional out parameters.

      Note 1: there is currently no way to know whether an OUT parameter
        is conditional, so all out parameters are marked conditional and
        taken to be so iff the function cannot throw an error and has a
        boolean return type.  Therefore this case cannot occur at the
        moment.


  inParamType[l]
    for l in 1 to L, is the SML type representing the
    <l>th parameter type in the list of non-VOID IN/INOUT parameter
    types of the function translated as follows:

      mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo
      typeInfo  = GIRepository.ArgInfo.getType argInfo

        mayBeNull        | inParamType
      ===================+===================
        false            | <type(typeInfo, false)>
      -------------------+-------------------
        true             | <type(typeInfo, false)> option
      -------------------+-------------------


  outParamType[k]
    for k in 1 to K, is the SML type representing the
    <k>th parameter type in the list of non-VOID INOUT/OUT
    parameter types of the function translated as follows:

      mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo
      typeInfo  = GIRepository.ArgInfo.getType argInfo

        mayBeNull        | outParamType
      ===================+===================
        false            | <type(typeInfo, dir = OUT)>
      -------------------+-------------------
        true             | <type(typeInfo, dir = OUT)> option
      -------------------+-------------------


  selfType
    is the SML type representing the object or interface
    that contains the function and has the form as follows:

      infoType = GIRepository.InfoType.getType containerInfo
      isClass = infoType is OBJECT _ | INTERFACE _
      isRecord = infoType is STRUCT _
      isUnion = infoType is UNION _
      isOther = not (isClass or isRecord)

        <var> class
          if isClass

        t
          if isRecord

        <var> union
          if isUnion

        t
          if isOther


  scalarType(typeInfo)
    is defined as according to the GIR type tag as follows:

      tag = GIRepository.TypeInfo.get_tag typeInfo

      Conversion from tag is as follows:

        BOOLEAN   --->    bool
        CHAR      --->    char
        UCHAR     --->    char
        INT       --->    LargeInt.int
        UINT      --->    LargeInt.int
        SHORT     --->    LargeInt.int
        USHORT    --->    LargeInt.int
        LONG      --->    LargeInt.int
        ULONG     --->    LargeInt.int
        INT8      --->    LargeInt.int
        UINT8     --->    Word8.word
        INT16     --->    LargeInt.int
        UINT16    --->    LargeInt.int
        INT32     --->    LargeInt.int
        UINT32    --->    LargeInt.int
        INT64     --->    LargeInt.int
        UINT64    --->    LargeInt.int
        FLOAT     --->    real
        DOUBLE    --->    real
        SSIZE     --->    LargeInt.int
        SIZE      --->    LargeInt.int
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UNICHAR   --->    char


  type(typeInfo, isOutParOrRet)
    is defined as according to the GIR type tag as follows:

      tag = GIRepository.TypeInfo.get_tag typeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        GTYPE     --->    <raise Error "not supported">
        FILENAME  --->    string
        ARRAY     --->    <ArrayStructId(typeInfo, isOutParOrRet)>.t
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    unit
                          -.
        BOOLEAN   --->     |
        CHAR      --->     |
        UCHAR     --->     |
        INT       --->     |
        UINT      --->     |
        SHORT     --->     |
        USHORT    --->     |
        LONG      --->     |
        ULONG     --->     |
        INT8      --->     |
        UINT8     --->     |
        INT16     --->     |
        UINT16    --->     |
        INT32     --->     | scalarType(typeInfo)
        UINT32    --->     |
        INT64     --->     |
        UINT64    --->     |
        FLOAT     --->     |
        DOUBLE    --->     |
        SSIZE     --->     |
        SIZE      --->     |
        OFFSET    --->     |
        INTPTR    --->     |
        UINTPTR   --->     |
        UNICHAR   --->     |
                          -'
        UTF8      --->    string

        INTERFACE --->

          interfaceTypeInfo = GIRepository.TypeInfo.getInterface typeInfo

          InterfaceName = GIRepository.BaseInfo.getName interfaceTypeInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace interfaceTypeInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          infoType = GIRepository.InfoType.getType interfaceTypeInfo
          isClass = infoType is OBJECT _ | INTERFACE _
          isRecord = infoType is STRUCT _
          isUnion = infoType is UNION _
          isOther = not (isClass or isRecord or isUnion)

          isGlobal = InterfaceNamespace <> FunctionNamespace
          isNamespace = optContainerName = NONE
          isSelf = SOME InterfaceName = optContainerName

            <var> <InterfaceNamespace>.<InterfaceName>Class.class
              if isGlobal and isClass

            <InterfaceNamespace>.<InterfaceName>Record.t
              if isGlobal and isRecord

            <var> <InterfaceNamespace>.<InterfaceName>.union
              if isGlobal and isUnion

            <InterfaceNamespace>.<InterfaceName>.t
              if isGlobal and isOther


            <var> <InterfaceName>Class.class
              if not isGlobal and isNamespace and isClass

            <InterfaceName>Record.t
              if not isGlobal and isNamespace and isRecord

            <var> <InterfaceName>.union
              if not isGlobal and isNamespace and isUnion

            <InterfaceName>.t
              if not isGlobal and isNamespace and isOther


            <var> <interface_name>_class
              if not isGlobal and not isNamespace and not isSelf and isClass

            <interface_name>_t
              if not isGlobal and not isNamespace and not isSelf and isRecord

            <var> <interface_name>_union
              if not isGlobal and not isNamespace and not isSelf and isUnion

            <interface_name>_t
              if not isGlobal and not isNamespace and not isSelf and isOther


            <var> class
              if not isGlobal and not isNamespace and isSelf and isClass

            t
              if not isGlobal and not isNamespace and isSelf and isRecord

            <var> union
              if not isGlobal and not isNamespace and isSelf and isUnion

            t
              if not isGlobal and not isNamespace and isSelf and isOther


  var
    is

      <"a fresh type variable">
        for selfType or a non-contained inParamType

      base
        for an outParamType or retType or contained type.

    A type is 'contained' when it is the element type of some container, e.g. array, list etc.



==High-Level Functions==

For
  J non-VOID parameters,
  K non-VOID non-length INOUT/OUT parameters,
  L non-VOID non-length IN/INOUT parameters,
  M length IN/INOUT parameters,
  N non-VOID INOUT/OUT parameters,
HighLevelFunction has a form as described below,
where a length parameter is one that provides the length of a C array in another parameter
or the return value, provided that the length parameter and the C array parameter have the
same direction or the length parameter for a C array return value has direction OUT.

Note that an IN parameter that provides the initial length of a C array OUT parameter or
return value is not considered to be a 'length' parameter above and, therefore, must be provided
by the caller.

Note that the condition 'N + M > 0' determines whether a let-expression is introduced.

We also treat J, K, L, M and N as arrays whose elements are the zero-based parameter index in the
full list of parameters.  Each array is injective (i.e. elements are unique) and the
inverse of an array X is denoted X~.


  fun <functionName> self (<inParamName[1]>, ..., <inParamName[L]>) =
    let
      val <lenParamName[1]> = <lenParamExp[1]>
      ...
      val <lenParamName[M]> = <lenParamExp[M]>

      val <outParamNamePat[1]> & ... & <outParamNamePat[N]> & <retValPat> =
        (<withFunSelf> &&&> <withFun[1]> &&&> ... &&&> <withFun[J]> [&&&> <withFunErr>]
          ---> <fromFun[1]> && ... && <fromFun[N]> && <retFromFun>)
          <functionName>_
          (self & <argVal[1]> & ... & <argVal[J]> [& <argValErr>])
    in
      <retExp>
    end

    if N + M > 0 and L > 0 and anySet (FunctionFlags, IS_METHOD)


  fun <functionName> self =
    let
      val <lenParamName[1]> = <lenParamExp[1]>
      ...
      val <lenParamName[M]> = <lenParamExp[M]>

      val <outParamNamePat[1]> & ... & <outParamNamePat[N]> & <retValPat> =
        (<withFunSelf> &&&> <withFun[1]> &&&> ... &&&> <withFun[J]> [&&&> <withFunErr>]
          ---> <fromFun[1]> && ... && <fromFun[N]> && <retFromFun>)
          <functionName>_
          (self & <argVal[1]> & ... & <argVal[J]> [& <argValErr>])
    in
      <retExp>
    end

    if N + M > 0 and L = 0 and anySet (FunctionFlags, IS_METHOD)


  fun <functionName> (<inParamName[1]>, ..., <inParamName[L]>) =
    let
      val <lenParamName[1]> = <lenParamExp[1]>
      ...
      val <lenParamName[M]> = <lenParamExp[M]>

      val <outParamNamePat[1]> & ... & <outParamNamePat[N]> & <retValPat> =
        (<withFun[1]> &&&> ... &&&> <withFun[J]> [&&&> <withFunErr>]
          ---> <fromFun[1]> && ... && <fromFun[N]> && <retFromFun>)
          <functionName>_
          (<argVal[1]> & ... & <argVal[J]> [& <argValErr>])
    in
      <retExp>
    end

    if N + M > 0 and not anySet (FunctionFlags, IS_METHOD)


  fun <functionName> self (<inParamName[1]>, ..., <inParamName[L]>) =
    (<withFunSelf> &&&> <withFun[1]> &&&> ... &&&> <withFun[J]> [&&&> <withFunErr>] ---> <retFromFun>)
      <functionName>_
      (self & <argVal[1]> & ... & <argVal[J]> [& <argValErr>])

    if N + M = 0 and L > 0 and anySet (FunctionFlags, IS_METHOD)


  fun <functionName> self =
    (<withFunSelf> &&&> <withFun[1]> &&&> ... &&&> <withFun[J]> [&&&> <withFunErr>] ---> <retFromFun>)
      <functionName>_
      (self & <argVal[1]> & ... & <argVal[J]> [& <argValErr>])

    if N + M = 0 and L = 0 and anySet (FunctionFlags, IS_METHOD)


  fun <functionName> (<inParamName[1]>, ..., <inParamName[L]>) =
    (<withFun[1]> &&&> ... &&&> <withFun[J]> [&&&> <withFunErr>] ---> <retFromFun>)
      <functionName>_
      (<argVal[1]> & ... & <argVal[J]> [& <argValErr>])

    if N + M = 0 and not anySet (FunctionFlags, IS_METHOD)


  fun <functionName> () =
    (<withFunErr> ---> <retFromFun>)
      <functionName>_
      <argValErr>

    if N + M = 0 and L = 0 and not anySet (FunctionFlags, IS_METHOD)
                       and anySet (FunctionFlags, THROWS)
      (note N = 0 and L = 0 and M = 0 iff J = 0)


  fun <functionName> () =
    (I ---> <retFromFun>)
      <functionName>_
      ()

    if N + M = 0 and L = 0 and not anySet (FunctionFlags, IS_METHOD)
                       and not anySet (FunctionFlags, THROWS)
      (note N = 0 and L = 0 and M = 0 iff J = 0)


where


  [<e>]
    is
      <e>
        if anySet (FunctionFlags, THROWS) and

      <empty>
        otherwise


  convertToInt(i, x)
    is defined as follows:

        lenArgInfo = GIRepository.CallableInfo.getArg functionInfo i
        lenArgTypeInfo = GIRepository.ArgInfo.getType lenArgInfo

          scalarType(lenArgTypeInfo)  | convertToInt(i, x)
        ==============================+========================================
          int                         | <x>
        ------------------------------+----------------------------------------
          LargeInt.int                | (LargeInt.toInt <x>)
        ------------------------------+----------------------------------------
          Word8.word                  | (Word8.toInt <x>)
        ------------------------------+----------------------------------------


  retValPat
    is defined as follows:

        retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
        tag         = GIRepository.TypeInfo.getTag retTypeInfo
        throws      = anySet (FunctionFlags, THROWS)

          tag     throws          | retValPat
        ==========================+===================
          VOID    _               | ()
        --------------------------+-------------------
          BOOLEAN true            | ()
        --------------------------+-------------------
          _       _               | retVal
        --------------------------+-------------------

    In the forms of a high-level function, the return value is not used
    when it is VOID or the function can throw an error.  Therefore the
    pattern `()` or `_` is be used instead of `retVal` to avoid warnings
    about unreferenced identifiers.


  retVal
    is defined as follows:

        retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
        tag         = GIRepository.TypeInfo.getTag retTypeInfo

          tag             | retVal
        ==================+===================
          VOID            | ()
        ------------------+-------------------
          _               | retVal <retValArrayLenExp>
        ------------------+-------------------

    where

      retValArrayLenExp
        is defined as follows:

          retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
          isZeroTerminated = GIRepository.TypeInfo.isZeroTerminated retTypeInfo
          arrayLengthParamIdx = GIRepository.TypeInfo.getArrayLength retTypeInfo
          arraySize = GIRepository.TypeInfo.getArrayFixedSize retTypeInfo

            isZeroTerminated    arrayLengthParamIdx     arraySize      _                   | outParamArrayLenExp
          =================================================================================+=========================
            _                   _                       <n>, n <> ~1   _                   | <n>
          ---------------------------------------------------------------------------------+-------------------------
            false               <i>, i <> ~1            ~1             _                   | <convertToInt(i, outParamName[N~[i]])>
          ---------------------------------------------------------------------------------+-------------------------
            false               ~1                      ~1             _                   | <raise Error "cannot determine array length">
          ---------------------------------------------------------------------------------+-------------------------
            true                <i>, i <> ~1            ~1             false               | <convertToInt(i, outParamName[N~[i]])>
          ---------------------------------------------------------------------------------+-------------------------
            true                <i>, i <> ~1            ~1             true                | <>
          ---------------------------------------------------------------------------------+-------------------------
            true                ~1                      ~1             _                   | <>
          ---------------------------------------------------------------------------------+-------------------------

            (The table above contains the condition false and true to match the
            form used in the definition of outParamArrayLenExp and ArrayType.)


  retExp
    when K = 0, retExp is <retVal>

    when K > 0, taking the numer of conditional outputs to be KA, where
    the indices of conditional outputs are ka[1], ..., ka[KA] and the
    indices of non-conditional outputs are kb[1], ..., kb[K - KA], is
    defined as follows:

        retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
        tag         = GIRepository.TypeInfo.getTag retTypeInfo
        throws      = anySet (FunctionFlags, THROWS)

          tag     throws  0 < KA  KA < K   | retExp
        ===================================+===================================================
          VOID    _       false   _        |
          VOID    true    _       _        | (<outParamExp[1]>, ..., <outParamExp[K]>)
          BOOLEAN true    _       _        |
        -----------------------------------+---------------------------------------------------
          _       _       false   _        | (retVal, <outParamExp[1]>, ..., <outParamExp[K]>)
          _       true    _       _        |
        -----------------------------------+---------------------------------------------------
          BOOLEAN false   true    false    | if retVal
                                           | then
                                           |   SOME (
                                           |     <outParamExp[1]>,
                                           |     ...,
                                           |     <outParamExp[KA]>
                                           |   )
                                           | else
                                           |   NONE
        -----------------------------------+---------------------------------------------------
          BOOLEAN false   true    true     | (
                                           |   if retVal
                                           |   then
                                           |     SOME (
                                           |       <outParamExp[ka[1]]>,
                                           |       ...,
                                           |       <outParamExp[ka[KA]]>
                                           |     )
                                           |   else
                                           |     NONE,
                                           |   <outParamName[kb[1]]>,
                                           |   ...
                                           |   <outParamName[kb[K - KA]]>
                                           | )
        -----------------------------------+---------------------------------------------------
          _       false   true    _        | <raise Error>                         (see note 1)
        -----------------------------------+---------------------------------------------------

    This logic is applied to prevent unknown/arbitrary/uninitialized out
    parameter values (especially pointers and caller-allocated structures)
    being returned to the application by using an option type for
    conditional out parameters.

      Note 1: there is currently no way to know whether an OUT parameter
        is conditional, so all out parameters are marked conditional and
        taken to be so iff the function cannot throw an error and has a
        boolean return type.  Therefore this case cannot occur at the
        moment.

    Generally, retExp is used to encode any additional logic that is applied
    above the high-level FFI.


  outParamNamePat[n]
    is defined as follows:

      _

        if
          either
            there exists a unique i, arrArgInfo and arrArgTypeInfo such that
              arrArgInfo = GIRepository.CallableInfo.getArg functionInfo i
              GIRepository.ArgInfo.getDirection arrArgInfo = OUT
              arrArgTypeInfo = GIRepository.ArgInfo.getType arrArgInfo
              <N[n]> = GIRepository.TypeInfo.getArrayLength arrArgTypeInfo
              GIRepository.TypeInfo.isZeroTerminated arrArgTypeInfo = true
          or
            there exists a unique retTypeInfo such that
              retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
              <N[n]> = GIRepository.TypeInfo.getArrayLength retTypeInfo
              GIRepository.TypeInfo.isZeroTerminated retTypeInfo = true

          i.e this is a length parameter for array returned in an OUT parameter
          or the return value where the array is also zero-terminated so the
          length parameter is not used.

      <outParamName[n]>

        otherwise


  outParamName[n]
    is defined as follows:

      <GIRepository.BaseInfo.getName functionInfo <N[n]>>

    i.e. the <n>th element in the list of names of non-VOID INOUT/OUT
    parameters of the function as given by `GIRepository.BaseInfo.getName`


  outParamExp[k]
    is defined as follows:

      <outParamName[N~[K[k]]]> <outParamArrayLenExp>

    where

      outParamArrayLenExp
        is defined as follows:

          argTypeInfo = GIRepository.ArgInfo.getType argInfo
          isZeroTerminated = GIRepository.TypeInfo.isZeroTerminated argTypeInfo
          arrayLengthParamIdx = GIRepository.TypeInfo.getArrayLength argTypeInfo
          arraySize = GIRepository.TypeInfo.getArrayFixedSize argTypeInfo
          dir = GIRepository.ArgInfo.getDirection argInfo

            isZeroTerminated    arrayLengthParamIdx     arraySize      dir                 | outParamArrayLenExp
          =================================================================================+=========================
            _                   _                       <n>, n <> ~1   _                   | <n>
          ---------------------------------------------------------------------------------+-------------------------
            false               <i>, i <> ~1            ~1             _                   | <convertToInt(i, outParamName[N~[i]])>
          ---------------------------------------------------------------------------------+-------------------------
            false               ~1                      ~1             _                   | <raise Error "cannot determine array length">
          ---------------------------------------------------------------------------------+-------------------------
            true                <i>, i <> ~1            ~1             IN | INOUT          | <convertToInt(i, outParamName[N~[i]])>
          ---------------------------------------------------------------------------------+-------------------------
            true                <i>, i <> ~1            ~1             OUT                 | <>
          ---------------------------------------------------------------------------------+-------------------------
            true                ~1                      ~1             _                   | <>
          ---------------------------------------------------------------------------------+-------------------------


  inParamName[l]
    is the <l>th element in the list of names of non-VOID non-length IN/INOUT
    parameters of the function as given by `GIRepository.BaseInfo.getName`.


  lenParamName[m]
    is the <m>th element in the list of names of IN/INOUT length
    parameters of the function as given by `GIRepository.BaseInfo.getName`.


  lenParamExp[m]
    is defined as follows:

      case <inParamName[L~[i]]> of
        SOME <inParamName[L~[i]]> => <lenParamSomeExp>
      | NONE                      => <lenParamNoneExp>

        if GIRepository.ArgInfo.mayBeNull arrArgInfo


      <lenParamSomeExp>

        otherwise

    where there exists a unique i, arrArgInfo and arrArgTypeInfo such that

      arrArgInfo = GIRepository.CallableInfo.getArg functionInfo i
      arrArgTypeInfo = GIRepository.ArgInfo.getType arrArgInfo
      <M[m]> = GIRepository.TypeInfo.getArrayLength arrArgTypeInfo

    where

      lenParamSomeExp
        is defined as follows:

          argTypeInfo = GIRepository.ArgInfo.getType argInfo
          tag = GIRepository.TypeInfo.get_tag argTypeInfo

          Conversion from tag is as follows:

            ERROR     --->    <raise Error "not expected">
            FILENAME  --->    <raise Error "not expected">
            ARRAY     --->    <raise Error "not expected">
            GLIST     --->    <raise Error "not expected">
            GSLIST    --->    <raise Error "not expected">
            GHASH     --->    <raise Error "not expected">
            VOID      --->    <raise Error "not expected">
            BOOLEAN   --->    <raise Error "not expected">
            CHAR      --->    <raise Error "not expected">
            UCHAR     --->    <raise Error "not expected">
            INT       --->    <convertFromInt>
            UINT      --->    <convertFromInt>
            SHORT     --->    <convertFromInt>
            USHORT    --->    <convertFromInt>
            LONG      --->    <convertFromInt>
            ULONG     --->    <convertFromInt>
            INT8      --->    <convertFromInt>
            UINT8     --->    <convertFromInt>
            INT16     --->    <convertFromInt>
            UINT16    --->    <convertFromInt>
            INT32     --->    <convertFromInt>
            UINT32    --->    <convertFromInt>
            INT64     --->    <convertFromInt>
            UINT64    --->    <convertFromInt>
            FLOAT     --->    <raise Error "not expected">
            DOUBLE    --->    <raise Error "not expected">
            SSIZE     --->    <convertFromInt>
            SIZE      --->    <convertFromInt>
            OFFSET    --->    <raise Error "not supported">
            INTPTR    --->    <raise Error "not supported">
            UINTPTR   --->    <raise Error "not supported">
            UNICHAR   --->    <raise Error "not expected">
            UTF8      --->    <raise Error "not expected">
            INTERFACE --->    <raise Error "not expected">


          convertFromInt is defined as follows:

              scalarType(argTypeInfo) | convertFromInt
            ======================+===================================
              int                     | <lenIntExp>
            --------------------------+-----------------------------------
              LargeInt.int            | LargeInt.fromInt (<lenIntExp>)
            --------------------------+-----------------------------------
              Word8.word              | Word8.fromInt (<lenIntExp>)
            --------------------------+-----------------------------------

          lenIntExp is defined as follows:

              <ArrayStructId(arrArgTypeInfo)>.length <inParamName[L~[i]]>


      lenParamNoneExp
        is defined as follows:

          argTypeInfo = GIRepository.ArgInfo.getType argInfo
          tag = GIRepository.TypeInfo.get_tag argTypeInfo

          Conversion from tag is as follows:

            ERROR     --->    <raise Error "not expected">
            FILENAME  --->    <raise Error "not expected">
            ARRAY     --->    <raise Error "not expected">
            GLIST     --->    <raise Error "not supported">
            GSLIST    --->    <raise Error "not supported">
            GHASH     --->    <raise Error "not supported">
            VOID      --->    <raise Error "not expected">
            BOOLEAN   --->    <raise Error "not expected">
            CHAR      --->    <raise Error "not expected">
            UCHAR     --->    <raise Error "not expected">
            INT       --->    GInt.null
            UINT      --->    GUInt.null
            SHORT     --->    GShort.null
            USHORT    --->    GUShort.null
            LONG      --->    GLong.null
            ULONG     --->    GULong.null
            INT8      --->    GInt8.null
            UINT8     --->    GUInt8.null
            INT16     --->    GInt16.null
            UINT16    --->    GUInt16.null
            INT32     --->    GInt32.null
            UINT32    --->    GUInt32.null
            INT64     --->    GInt64.null
            UINT64    --->    GUInt64.null
            FLOAT     --->    <raise Error "not expected">
            DOUBLE    --->    <raise Error "not expected">
            SSIZE     --->    GSSize.null
            SIZE      --->    GSize.null
            OFFSET    --->    <raise Error "not supported">
            INTPTR    --->    <raise Error "not supported">
            UINTPTR   --->    <raise Error "not supported">
            UTF8      --->    <raise Error "not expected">
            UNICHAR   --->    <raise Error "not expected">
            INTERFACE --->    <raise Error "not expected">


  withFunSelf
    is <withInterfaceFun> where the interface is the enclosing entity.
    Note that the GIR type tag of the enclosing entity must be INTERFACE: no
    other type tag is an entity that has functions.


  withFunErr
    is GLibErrorRecord.handleError


  withFun[j]
    is defined according to the GIR type tag of the type of the
    <j>th non-VOID parameter ('argument') of the function as follows:

      argTypeInfo = GIRepository.ArgInfo.getType argInfo
      tag = GIRepository.TypeInfo.get_tag argTypeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    <withUtf8Fun>
        ARRAY     --->    <withArrayFun>
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    <raise Error "not expected">
        BOOLEAN   --->    <withValFun(GBool.FFI)>
        CHAR      --->    <withValFun(GChar.FFI)>
        UCHAR     --->    <withValFun(GUChar.FFI)>
        INT       --->    <withValFun(GInt.FFI)>
        UINT      --->    <withValFun(GUInt.FFI)>
        SHORT     --->    <withValFun(GShort.FFI)>
        USHORT    --->    <withValFun(GUShort.FFI)>
        LONG      --->    <withValFun(GLong.FFI)>
        ULONG     --->    <withValFun(GULong.FFI)>
        INT8      --->    <withValFun(GInt8.FFI)>
        UINT8     --->    <withValFun(GUInt8.FFI)>
        INT16     --->    <withValFun(GInt16.FFI)>
        UINT16    --->    <withValFun(GUInt16.FFI)>
        INT32     --->    <withValFun(GInt32.FFI)>
        UINT32    --->    <withValFun(GUInt32.FFI)>
        INT64     --->    <withValFun(GInt64.FFI)>
        UINT64    --->    <withValFun(GUInt64.FFI)>
        FLOAT     --->    <withValFun(GFloat.FFI)>
        DOUBLE    --->    <withValFun(GDouble.FFI)>
        SSIZE     --->    <withValFun(GSSize.FFI)>
        SIZE      --->    <withValFun(GSize.FFI)>
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    <withUtf8Fun>
        UNICHAR   --->    <withValFun(GChar.FFI)>
        INTERFACE --->    <withInterfaceFun>


  withValFun(A)
    is defined as follows:

          direction       | withValFun(A)
        ==================+===========================
          IN              | <A>.withVal
        ------------------+---------------------------
          OUT             | <A>.withRefVal
        ------------------+---------------------------
          INOUT           | <A>.withRefVal
        ------------------+---------------------------


  withUtf8Fun
    is defined as follows:

        direction         = GIRepository.ArgInfo.getDirection argInfo
        mayBeNull         = GIRepository.ArgInfo.mayBeNull argInfo
        ownershipTransfer = GIRepository.ArgInfo.getOwnershipTransfer argInfo
        isPointer         = GIRepository.TypeInfo.isPointer argTypeInfo

          direction   isPointer   ownershipTra... | withUtf8Fun
        ==========================================+===============================================
                                  NOTHING         | <raise Error nonPtrForUtf8InPar>
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <raise Error nonPtrForUtf8InPar>
          IN        ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.with<Opt>Ptr 0                (see note 1)
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.with<Opt>Ptr ~1               (see note 2)
        ------------------------------------------+-----------------------------------------------
                                  NOTHING         | <raise Error nonPtrForUtf8OutPar> (see note 4)
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <raise Error nonPtrForUtf8OutPar> (see note 4)
          OUT       ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.withRefOptPtr 0
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.withRefOptPtr 0
        ------------------------------------------+-----------------------------------------------
                                  NOTHING         | <raise Error nothingForNonPtrUtf8InOutPar>
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.withDup<Opt>Ptr
          INOUT     ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.withRef<Opt>Ptr 0             (see note 1)
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.withRef<Opt>Ptr ~1            (see note 3)
        ------------------------------------------+-----------------------------------------------

          Note 1: we assume that the parameter is not destructively updated so
            don't give a non-zero argument to `with[Ref][Opt]Ptr` to provide a copy.

          Note 2: if ownership is transferred for an IN parameter, the function
            may destructively update the parameter so `with[Opt]Ptr` is used with a
            non-zero argument to provide a copy; note that although ownership is not transferred back
            via the IN parameter, it is possible that ownership is transferred back
            via another parameter or the return value, e.g. g_environ_setenv.

          Note 3: ownership transfer EVERYTHING is not the same as NOTHING:
            handing ownership to the function and taking ownership back allows
            the function to free and/or allocate memory.

          Note 4: unlike an ARRAY OUT parameter, it is not possible for the caller to
            allocate memory for a UTF8 OUT parameter because girepository does not
            allow a length parameter or fixed size to be specified for non ARRAY types
            so there is no way of knowing the size to allocate.

      A is Utf8.FFI

      Opt is defined as follows:

          mayBeNull       | Opt
        ==================+===================
          false           | <empty>
        ------------------+-------------------
          true            | Opt
        ------------------+-------------------


  withArrayFun
    is defined as follows:

        direction         = GIRepository.ArgInfo.getDirection argInfo
        mayBeNull         = GIRepository.ArgInfo.mayBeNull argInfo
        ownershipTransfer = GIRepository.ArgInfo.getOwnershipTransfer argInfo
        isPointer         = GIRepository.TypeInfo.isPointer argTypeInfo

          direction   isPointer   ownershipTra... | withArrayFun
        ==========================================+===============================================
                                  NOTHING         | <raise Error nonPtrForArrayInPar>
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <raise Error nonPtrForArrayInPar>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <raise Error nonPtrForArrayInPar>
          IN        ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.with<Opt>Ptr 0                (see note 1)
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <A>.with<Opt>Ptr 1                (see note 2)
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.with<Opt>Ptr ~1               (see note 2)
        ------------------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.withNewPtr
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <raise Error containerForNonPtrArrayOutPar>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <raise Error everythingForNonPtrArrayOutPar>
          OUT       ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.withRefOptPtr 0
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <A>.withRefOptPtr 0
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.withRefOptPtr 0
        ------------------------------------------+-----------------------------------------------
                                  NOTHING         | <raise Error nothingForNonPtrArrayInOutPar>
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <A>.withDup<Opt>Ptr
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.withDup<Opt>Ptr
          INOUT     ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.withRef<Opt>Ptr 0             (see note 1)
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <A>.withRef<Opt>Ptr 1             (see note 3)
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.withRef<Opt>Ptr ~1            (see note 3)
        ------------------------------------------+-----------------------------------------------

          Note 1: we assume that the parameter is not destructively updated so
            don't give a non-zero argument to `with[Ref][Opt]Ptr` to provide a copy.

          Note 2: if ownership is transferred for an IN parameter, the function
            may destructively update the parameter so `with[Opt]Ptr` is used with a
            non-zero argument to provide a copy; note that although ownership is not transferred back
            via the IN parameter, it is possible that ownership is transferred back
            via another parameter or the return value, e.g. g_environ_setenv.

          Note 3: ownership transfer EVERYTHING is not the same as NOTHING:
            handing ownership to the function and taking ownership back allows
            the function to free and/or allocate memory.

      A is <ArrayStructId(argTypeInfo)>.FFI

      Opt is defined as follows:

          mayBeNull       | Opt
        ==================+===================
          false           | <empty>
        ------------------+-------------------
          true            | Opt
        ------------------+-------------------


  withInterfaceFun
    is defined according to the interface type as follows:

      argInterfaceTypeInfo = GIRepository.TypeInfo.getInterface argTypeInfo
      argInfoType = GIRepository.InfoType.getType argInterfaceTypeInfo

      <withObjectFun>
        if argInfoType is OBJECT argObjectInfo, where

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <raise Error nonPtrForObject>
            ------------------+-----------------------------------
              true            | <>
            ------------------+-----------------------------------

          withObjectFun is defined as follows:

            direction         = GIRepository.ArgInfo.getDirection argInfo
            mayBeNull         = GIRepository.ArgInfo.mayBeNull argInfo
            ownershipTransfer = GIRepository.ArgInfo.getOwnershipTransfer argInfo

              direction   ownershipTra... | withObjectFun
            ==============================+===============================================
                          NOTHING         | <A>.with<Opt>Ptr false
                        ------------------+-----------------------------------------------
              IN          EVERYTHING      | <A>.with<Opt>Ptr true             (see note 1)
                        ------------------+-----------------------------------------------
                          CONTAINER       | <raise Error containerForInterface>
            ------------------------------+-----------------------------------------------
                          NOTHING         | <A>.withRefOptPtr false
                        ------------------+-----------------------------------------------
              OUT         EVERYTHING      | <A>.withRefOptPtr false
                        ------------------+-----------------------------------------------
                          CONTAINER       | <raise Error containerForInterface>
            ------------------------------+-----------------------------------------------
                          NOTHING         | <A>.withRef<Opt>Ptr false
                        ------------------+-----------------------------------------------
              INOUT       EVERYTHING      | <A>.withRef<Opt>Ptr true
                        ------------------+-----------------------------------------------
                          CONTAINER       | <raise Error containerForInterface>
            ------------------------------+-----------------------------------------------

              Note 1: if a reference is handed over for an IN parameter, the function
                does not pass the reference back so `with[Opt]Ptr` is used with argument true to
                provide a duplicate reference; note that although ownership is not
                transferred back via the IN parameter, it is possible that ownership is
                transferred back via another parameter or the return value.

          A is <ObjectNamespace><ObjectName>Class.FFI

          ObjectName = GIRepository.BaseInfo.getName argObjectInfo
          ObjectNamespace = GIRepository.BaseInfo.getNamespace argObjectInfo

          Opt is defined as follows:

              mayBeNull       | Opt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------


      <raise Error>  # for now
        if argInfoType is INTERFACE _.


      <withStructFun>
        if argInfoType is STRUCT _, where

          withStructFun is defined as follows:

            direction         = GIRepository.ArgInfo.getDirection argInfo
            mayBeNull         = GIRepository.ArgInfo.mayBeNull argInfo
            ownershipTransfer = GIRepository.ArgInfo.getOwnershipTransfer argInfo
            argTypeInfo       = GIRepository.ArgInfo.getType argInfo
            isPointer         = GIRepository.TypeInfo.isPointer argTypeInfo

              direction   isPointer   ownershipTra... | withStructFun
            ==========================================+===============================================
                                      NOTHING         | <raise Error nonPtrForStructInPar>
                                    ------------------+-----------------------------------------------
                          false       EVERYTHING      | <raise Error nonPtrForStructInPar>
                                    ------------------+-----------------------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
              IN        ------------------------------+-----------------------------------------------
                                      NOTHING         | <A>.with<Opt>Ptr false
                                    ------------------+-----------------------------------------------
                          true        EVERYTHING      | <A>.with<Opt>Ptr true             (see note 1)
                                    ------------------+-----------------------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
            ------------------------------------------+-----------------------------------------------
                                      NOTHING         | <A>.withNewPtr
                                    ------------------+-----------------------------------------------
                          false       EVERYTHING      | <raise Error everythingForNonPtrStructOutPar>
                                    ------------------+-----------------------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
              OUT       ------------------------------+-----------------------------------------------
                                      NOTHING         | <A>.withRefOptPtr false
                                    ------------------+-----------------------------------------------
                          true        EVERYTHING      | <A>.withRefOptPtr false
                                    ------------------+-----------------------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
            ------------------------------------------+-----------------------------------------------
                                      NOTHING         | <raise Error nothingForNonPtrStructInOutPar>
                                    ------------------+-----------------------------------------------
                          false       EVERYTHING      | <A>.withDup<Opt>Ptr
                                    ------------------+-----------------------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
              INOUT     ------------------------------+-----------------------------------------------
                                      NOTHING         | <A>.withRef<Opt>Ptr false
                                    ------------------+-----------------------------------------------
                          true        EVERYTHING      | <A>.withRef<Opt>Ptr true
                                    ------------------+-----------------------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
            ------------------------------------------+-----------------------------------------------

              Note 1: for a non-reference counted struct,
                if ownership is transferred for an IN parameter, the function
                may destructively update the parameter so `with[Opt]Ptr` is used
                with argument true to provide a copy; for a reference counted struct,
                if a reference is handed over for an IN parameter, the function
                does not pass the reference back so `with[Opt]Ptr` is used with arugment true to
                provide a duplicate reference; note that although ownership is not
                transferred back via the IN parameter, it is possible that ownership is
                transferred back via another parameter or the return value.

          A is defined as follows:

            <InterfaceNamespace><InterfaceName>.FFI
              if SOME <InterfaceName> is not equal to <optContainerName>, where

                InterfaceName = GIRepository.BaseInfo.getName argTypeInfo
                InterfaceNamespace = GIRepository.BaseInfo.getNamespace argTypeInfo
                InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          Opt is defined as follows:

              mayBeNull       | Opt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------

        It is necessary to handle the case when `isPointer` is false explicitly.
        When a STRUCT is not passed as a pointer, but a reference to a value, the
        'standard' scheme would require a value representation of a STRUCT in
        SML, like e.g. an INT32.  This is not possible for a STRUCT in general
        as some are opaque, e.g. GtkTextIter, though it could well be useful for
        a non-opaque STRUCT, e.g. GtkAccelKey.  Therefore, a reference to a STRUCT
        value is treated as a pointer.


      <withFlagsEnumFun>
        if argInfoType is FLAGS _ | ENUM _.

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <>
            ------------------+-----------------------------------
              true            | <raise Error ptrForFlagsEnum>
            ------------------+-----------------------------------

          withFlagsEnumFun is defined as follows:

              direction   | withFlagsEnumFun
            ==============+===================================
              IN          | <A>.withVal
            --------------+-----------------------------------
              OUT         | <A>.withRefVal
            --------------+-----------------------------------
              INOUT       | <A>.withRefVal
            --------------+-----------------------------------

          A is defined as follows:

            <InterfaceNamespace><InterfaceName>.FFI
              if (<InterfaceNamespace>, SOME <InterfaceName>) is not equal
              to (<FunctionNamespace>, <optContainerName>), where

                InterfaceName = GIRepository.BaseInfo.getName argTypeInfo
                InterfaceNamespace = GIRepository.BaseInfo.getNamespace argTypeInfo
                InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

            FFI
              otherwise


      <raise Error "not supported">
        if argInfoType is CALLBACK _.

        Note that CALLBACK can have
          mayBeNull = true
          isPointer = false
        i.e. isOpt implies isPointer does not necessarily hold.


      <raise Error "not supported">  # ignore other cases for now
        otherwise.


  fromFun
    is defined according to the GIR type tag of the type of the
    <k>th non-VOID INOUT/OUT parameter ('argument') of the
    function as follows:

      argTypeInfo = GIRepository.ArgInfo.getType argInfo
      tag = GIRepository.TypeInfo.get_tag argTypeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    <fromUtf8Fun>
        ARRAY     --->    <fromArrayFun>
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    <raise Error "not expected">
        BOOLEAN   --->    <fromValFun(GBool.FFI)>
        CHAR      --->    <fromValFun(GChar.FFI)>
        UCHAR     --->    <fromValFun(GUChar.FFI)>
        INT       --->    <fromValFun(GInt.FFI)>
        UINT      --->    <fromValFun(GUInt.FFI)>
        SHORT     --->    <fromValFun(GShort.FFI)>
        USHORT    --->    <fromValFun(GUShort.FFI)>
        LONG      --->    <fromValFun(GLong.FFI)>
        ULONG     --->    <fromValFun(GULong.FFI)>
        INT8      --->    <fromValFun(GInt8.FFI)>
        UINT8     --->    <fromValFun(GUInt8.FFI)>
        INT16     --->    <fromValFun(GInt16.FFI)>
        UINT16    --->    <fromValFun(GUInt16.FFI)>
        INT32     --->    <fromValFun(GInt32.FFI)>
        UINT32    --->    <fromValFun(GUInt32.FFI)>
        INT64     --->    <fromValFun(GInt64.FFI)>
        UINT64    --->    <fromValFun(GUInt64.FFI)>
        FLOAT     --->    <fromValFun(GFloat.FFI)>
        DOUBLE    --->    <fromValFun(GDouble.FFI)>
        SSIZE     --->    <fromValFun(GSSize.FFI)>
        SIZE      --->    <fromValFun(GSize.FFI)>
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    <fromUtf8Fun>
        UNICHAR   --->    <fromValFun(GChar.FFI)>
        INTERFACE --->    <fromInterfaceFun>


  fromValFun(A)
    is defined as follows:

          direction       | fromValFun(A)
        ==================+===========================
          IN              | <A>.fromVal
        ------------------+---------------------------
          OUT             | <A>.fromRefVal
        ------------------+---------------------------
          INOUT           | <A>.fromRefVal
        ------------------+---------------------------


  fromUtf8Fun
    is as follows:

        direction         = GIRepository.ArgInfo.getDirection argInfo
        mayBeNull         = GIRepository.ArgInfo.mayBeNull argInfo
        ownershipTransfer = GIRepository.ArgInfo.getOwnershipTransfer argInfo
        isPointer         = GIRepository.TypeInfo.isPointer argTypeInfo

          direction   isPointer   ownershipTra... | fromArrayFun
        ==========================================+===============================================
                                  NOTHING         | <raise Error nonPtrForUtf8OutPar> (see note 2)
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <raise Error nonPtrForUtf8OutPar> (see note 2)
          OUT       ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.from<Opt>Ptr 0
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.from<Opt>Ptr ~1
        ------------------------------------------+-----------------------------------------------
                                  NOTHING         | <raise Error nothingForNonPtrUtf8InOutPar>
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.from<Opt>Ptr ~1
          INOUT     ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.from<Opt>Ptr 0                (see note 1)
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <raise Error containerForUtf8>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.from<Opt>Ptr ~1               (see note 1)
        ------------------------------------------+-----------------------------------------------

          Note 1: ownership transfer EVERYTHING is not the same as NOTHING:
            handing ownership to the function and taking ownership back allows
            the function to free and/or allocate memory.

          Note 2: unlike an ARRAY OUT parameter, it is not possible for the caller to
            allocate memory for a UTF8 OUT parameter because girepository does not
            allow a length parameter or fixed size to be specified for non ARRAY types
            so there is no way of knowing the size to allocate.

      A is Utf8.FFI

      Opt is defined as follows:

          mayBeNull       | Opt
        ==================+===================
          false           | <empty>
        ------------------+-------------------
          true            | Opt
        ------------------+-------------------


  fromArrayFun
    is as follows:

        direction         = GIRepository.ArgInfo.getDirection argInfo
        mayBeNull         = GIRepository.ArgInfo.mayBeNull argInfo
        ownershipTransfer = GIRepository.ArgInfo.getOwnershipTransfer argInfo
        isPointer         = GIRepository.TypeInfo.isPointer argTypeInfo

          direction   isPointer   ownershipTra... | fromArrayFun
        ==========================================+===============================================
                                  NOTHING         | <A>.fromPtr ~1
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <raise Error containerForNonPtrArrayOutPar>
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <raise Error everythingForNonPtrArrayOutPar>
          OUT       ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.from<Opt>Ptr 0
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <A>.from<Opt>Ptr 1
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.from<Opt>Ptr ~1
        ------------------------------------------+-----------------------------------------------
                                  NOTHING         | <raise Error nothingForNonPtrArrayInOutPar>
                                ------------------+-----------------------------------------------
                      false       CONTAINER       | <A>.from<Opt>Ptr ~1
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.from<Opt>Ptr ~1
          INOUT     ------------------------------+-----------------------------------------------
                                  NOTHING         | <A>.from<Opt>Ptr 0                (see note 1)
                                ------------------+-----------------------------------------------
                      true        CONTAINER       | <A>.from<Opt>Ptr 1                (see note 1)
                                ------------------+-----------------------------------------------
                                  EVERYTHING      | <A>.from<Opt>Ptr ~1               (see note 1)
        ------------------------------------------+-----------------------------------------------

          Note 1: ownership transfer EVERYTHING is not the same as NOTHING:
            handing ownership to the function and taking ownership back allows
            the function to free and/or allocate memory.

      A is <ArrayStructId(argTypeInfo)>.FFI

      Opt is defined as follows:

          mayBeNull       | Opt
        ==================+===================
          false           | <empty>
        ------------------+-------------------
          true            | Opt
        ------------------+-------------------


  fromInterfaceFun
    is defined according to the interface type as follows:

      argInterfaceTypeInfo = GIRepository.TypeInfo.getInterface argTypeInfo
      argInfoType = GIRepository.InfoType.getType argInterfaceTypeInfo

      <fromObjectFun>
        if argInfoType is OBJECT argObjectInfo, where

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <raise Error nonPtrForObject>
            ------------------+-----------------------------------
              true            | <>
            ------------------+-----------------------------------

          fromObjectFun is defined as follows:

            direction         = GIRepository.ArgInfo.getDirection argInfo
            mayBeNull         = GIRepository.ArgInfo.mayBeNull argInfo
            ownershipTransfer = GIRepository.ArgInfo.getOwnershipTransfer argInfo

              direction   ownershipTra... | fromObjectFun
            ==============================+===================================
                          NOTHING         | <A>.from<Opt>Ptr false
                        ------------------+-----------------------------------
              OUT         EVERYTHING      | <A>.from<Opt>Ptr true
                        ------------------+-----------------------------------
                          CONTAINER       | <raise Error containerForInterface>
            ------------------------------+-----------------------------------
                          NOTHING         | <A>.from<Opt>Ptr false
                        ------------------+-----------------------------------
              INOUT       EVERYTHING      | <A>.from<Opt>Ptr true
                        ------------------+-----------------------------------
                          CONTAINER       | <raise Error containerForInterface>
            ------------------------------+-----------------------------------

          A is <InterfaceNamespace><InterfaceName>Class.FFI

          InterfaceName = GIRepository.BaseInfo.getName argObjectInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace argObjectInfo

          Opt is defined as follows:

              mayBeNull       | Opt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------


      <raise Error>  # for now
        if argInfoType is INTERFACE _.


      <fromStructFun>
        if argInfoType is STRUCT argStructInfo, where

          fromStructFun is defined as follows:

            direction         = GIRepository.ArgInfo.getDirection argInfo
            mayBeNull         = GIRepository.ArgInfo.mayBeNull argInfo
            ownershipTransfer = GIRepository.ArgInfo.getOwnershipTransfer argInfo

            isPointer         = GIRepository.TypeInfo.isPointer argTypeInfo

              direction   isPointer   ownershipTra... | fromStructFun
            ==========================================+===================================
                                      NOTHING         | <A>.fromPtr true
                                    ------------------+-----------------------------------
                          false       EVERYTHING      | <raise Error everythingForNonPtrStructOutPar>
                                    ------------------+-----------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
              OUT       ------------------------------+-----------------------------------
                                      NOTHING         | <A>.from<Opt>Ptr false  (see note 1)
                                    ------------------+-----------------------------------
                          true        EVERYTHING      | <A>.from<Opt>Ptr true
                                    ------------------+-----------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
            ------------------------------------------+-----------------------------------
                                      NOTHING         | <raise Error nothingForNonPtrStructInOutPar>
                                    ------------------+-----------------------------------
                          false       EVERYTHING      | <A>.from<Opt>Ptr true
                                    ------------------+-----------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
              INOUT     ------------------------------+-----------------------------------
                                      NOTHING         | <A>.from<Opt>Ptr false
                                    ------------------+-----------------------------------
                          true        EVERYTHING      | <A>.from<Opt>Ptr true
                                    ------------------+-----------------------------------
                                      CONTAINER       | <raise Error containerForInterface>
            ------------------------------------------+-----------------------------------

              Note 1: we cannot hold on to a reference to data that we do
                not own.  Therefore, for structures that do not support
                reference counting, a copy must be made when there is no
                transfer.

          A is <InterfaceNamespace><InterfaceName>Record.FFI

          InterfaceName = GIRepository.BaseInfo.getName argStructInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace argStructInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          Opt is defined as follows:

              mayBeNull       | Opt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------

        It is necessary to handle the case when `isPointer` is false explicitly.
        When a STRUCT is not passed as a pointer, but a reference to a value, the
        'standard' scheme would require a value representation of a STRUCT in
        SML, like e.g. an INT32.  This is not possible for a STRUCT in general
        as some are opaque, e.g. GtkTextIter, though it could well be useful for
        a non-opaque STRUCT, e.g. GtkAccelKey.  Therefore, a reference to a STRUCT
        value is treated as a pointer.


      <fromFlagsEnumFun>
        if argInfoType is FLAGS argFlagsEnumInfo | ENUM argFlagsEnumInfo.

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <>
            ------------------+-----------------------------------
              true            | <raise Error ptrForFlagsEnum>
            ------------------+-----------------------------------

          fromFlagsEnumFun is <A>.fromVal

          A is defined as follows:

            <InterfaceNamespace><InterfaceName>.FFI
              if (<InterfaceNamespace>, SOME <InterfaceName>) is not equal
              to (<FunctionNamespace>, <optContainerName>), where

                InterfaceName = GIRepository.BaseInfo.getName argFlagsEnumInfo
                InterfaceNamespace = GIRepository.BaseInfo.getNamespace argFlagsEnumInfo
                InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

            FFI
              otherwise


      <raise Error "not supported">
        if argInfoType is CALLBACK _.

        Note that CALLBACK can have
          mayBeNull = true
          isPointer = false
        i.e. isOpt implies isPointer does not necessarily hold.


      <raise Error "not supported">  # ignore other cases for now
        otherwise.


  retFromFun
    is defined according to the GIR type tag of the return type of
    the function as follows:

      retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
      tag = GIRepository.TypeInfo.get_tag retTypeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    <retFromUtf8Fun>
        ARRAY     --->    <retFromArrayFun>
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    I
        BOOLEAN   --->    <retFromBooleanFun>
        CHAR      --->    <retFromValFun(GChar.FFI)>
        UCHAR     --->    <retFromValFun(GUChar.FFI)>
        INT       --->    <retFromValFun(GInt.FFI)>
        UINT      --->    <retFromValFun(GUInt.FFI)>
        SHORT     --->    <retFromValFun(GShort.FFI)>
        USHORT    --->    <retFromValFun(GUShort.FFI)>
        LONG      --->    <retFromValFun(GLong.FFI)>
        ULONG     --->    <retFromValFun(GULong.FFI)>
        INT8      --->    <retFromValFun(GInt8.FFI)>
        UINT8     --->    <retFromValFun(GUInt8.FFI)>
        INT16     --->    <retFromValFun(GInt16.FFI)>
        UINT16    --->    <retFromValFun(GUInt16.FFI)>
        INT32     --->    <retFromValFun(GInt32.FFI)>
        UINT32    --->    <retFromValFun(GUInt32.FFI)>
        INT64     --->    <retFromValFun(GInt64.FFI)>
        UINT64    --->    <retFromValFun(GUInt64.FFI)>
        FLOAT     --->    <retFromValFun(GFloat.FFI)>
        DOUBLE    --->    <retFromValFun(GDouble.FFI)>
        SSIZE     --->    <retFromValFun(GSSize.FFI)>
        SIZE      --->    <retFromValFun(GSize.FFI)>
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    <retFromUtf8Fun>
        UNICHAR   --->    <retFromValFun(GChar.FFI)>
        INTERFACE --->    <retFromInterfaceFun>


  retFromValFun(A) is defined as fromValFun(A)


  retFromBooleanFun
    is as follows:

        throws = anySet (FunctionFlags, THROWS)

          tag     throws          | retFromBooleanFun
        ==========================+===================
          BOOLEAN true            | ignore
        --------------------------+-------------------
          _       _               | <retFromValFun(GBool.FFI)>
        --------------------------+-------------------


  retFromUtf8Fun
    is as follows:

        mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo
        getCallerOwns = GIRepository.CallableInfo.getCallerOwns functionInfo
        retTypeInfo   = GIRepository.CallableInfo.getReturnType functionInfo
        isPointer     = GIRepository.TypeInfo.isPointer retTypeInfo

          isPointer   getCallerOwns   | retFromArrayFun
        ==============================+===================================
          false       _               | <raise Error nonPtrForUtf8Ret>
        ------------------------------+-----------------------------------
                      NOTHING         | <A>.from<Opt>Ptr 0
                    ------------------+-----------------------------------
          true        CONTAINER       | <raise Error containerForUtf8>
                    ------------------+-----------------------------------
                      EVERYTHING      | <A>.from<Opt>Ptr ~1
        ------------------------------+-----------------------------------

      A is Utf8.FFI

      Opt is as follows:

          mayReturnNull   | Opt
        ==================+===========================
          false           | <empty>
        ------------------+---------------------------
          true            | Opt
        ------------------+---------------------------


  retFromArrayFun
    is as follows:

        mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo
        getCallerOwns = GIRepository.CallableInfo.getCallerOwns functionInfo
        retTypeInfo   = GIRepository.CallableInfo.getReturnType functionInfo
        isPointer     = GIRepository.TypeInfo.isPointer retTypeInfo

          isPointer   getCallerOwns   | retFromArrayFun
        ==============================+===================================
          false       _               | <raise Error nonPtrForArrayRet>
        ------------------------------+-----------------------------------
                      NOTHING         | <A>.from<Opt>Ptr 0
                    ------------------+-----------------------------------
          true        CONTAINER       | <A>.from<Opt>Ptr 1
                    ------------------+-----------------------------------
                      EVERYTHING      | <A>.from<Opt>Ptr ~1
        ------------------------------+-----------------------------------

      A is <ArrayStructId(retTypeInfo)>.FFI

      Opt is as follows:

          mayReturnNull   | Opt
        ==================+===========================
          false           | <empty>
        ------------------+---------------------------
          true            | Opt
        ------------------+---------------------------


  retFromInterfaceFun
    is defined according to the interface type as follows:

      retInterfaceTypeInfo = GIRepository.TypeInfo.getInterface retTypeInfo
      retInfoType = GIRepository.InfoType.getType retInterfaceTypeInfo

      <retFromObjectFun>
        if retInfoType is OBJECT retObjectInfo, where

            isPointer = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <raise Error nonPtrForObject>
            ------------------+-----------------------------------
              true            | <>
            ------------------+-----------------------------------

          retFromObjectFun is defined as follows:

            getCallerOwns = GIRepository.CallableInfo.getCallerOwns functionInfo

              getCallerOwns   | retFromObjectFun
            ==================+===================================
              NOTHING         | <A>.from<RetOpt>Ptr false
            ------------------+-----------------------------------
              EVERYTHING      | <A>.from<RetOpt>Ptr true
            ------------------+-----------------------------------
              CONTAINER       | <raise Error containerForInterface>
            ------------------+-----------------------------------

          A is defined as follows:

            <ContainerNamespace><ContainerName>Class.FFI
              if anySet (FunctionFlags, IS_CONSTRUCTOR), where

                SOME containerInfo = optContainerInfo
                ContainerName = GIRepository.BaseInfo.getName containerInfo
                ContainerNamespace = GIRepository.BaseInfo.getNamespace containerInfo
                ContainerCPrefix = GIRepository.getCPrefix repo <ContainerNamespace>

            <InterfaceNamespace><InterfaceName>Class.FFI
              otherwise, where

                InterfaceName = GIRepository.BaseInfo.getName retObjectInfo
                InterfaceNamespace = GIRepository.BaseInfo.getNamespace retObjectInfo
                InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          RetOpt is defined as follows:

            mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

              mayReturnNull   | RetOpt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------


      <retFromStructFun>
        if retInfoType is STRUCT argStructInfo, where

          retFromStructFun is the same as fromStructFun with direction = OUT.

          retFromStructFun is defined as follows:

            getCallerOwns = GIRepository.CallableInfo.getCallerOwns functionInfo

            isPointer     = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer   getCallerOwns   | retFromStructFun
            ==============================+===================================
              false       _               | <raise Error nonPtrForStructRet>
            ------------------------------+-----------------------------------
                          NOTHING         | <A>.from<RetOpt>Ptr false  (see note 1)
                        ------------------+-----------------------------------
              true        EVERYTHING      | <A>.from<RetOpt>Ptr true
                        ------------------+-----------------------------------
                          CONTAINER       | <raise Error containerForInterface>
            ------------------------------+-----------------------------------

              Note 1: we cannot hold on to a reference to data that we do
                not own.  Therefore, for structures that do not support
                reference counting, a copy must be made when there is no
                transfer.

          A is <InterfaceNamespace><InterfaceName>Record.FFI

          InterfaceName = GIRepository.BaseInfo.getName argStructInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace argStructInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          RetOpt is defined as follows:

            mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

              mayReturnNull   | RetOpt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------

        It is necessary to handle the case when `isPointer` is false explicitly.
        When a STRUCT is not passed as a pointer, but a reference to a value, the
        'standard' scheme would require a value representation of a STRUCT in
        SML, like e.g. an INT32.  This is not possible for a STRUCT in general
        as some are opaque, e.g. GtkTextIter, though it could well be useful for
        a non-opaque STRUCT, e.g. GtkAccelKey.  Therefore, a reference to a STRUCT
        value is treated as a pointer.


      <raise Error>  # for now
        if retInfoType is INTERFACE _.


      <InterfaceNamespace><InterfaceName>.FFI.fromVal
        if retInfoType is FLAGS _ | ENUM _.

            isPointer = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <>
            ------------------+-----------------------------------
              true            | <raise Error ptrForFlagsEnum>
            ------------------+-----------------------------------


      <raise Error "not supported">  # ignore other cases for now
        otherwise.


  argValErr
    is [<errorDomain[1]>, ..., <errorDomain[E]>]


  argVal[j]
    is defined according to the GIR type tag of the type of the
    <j>th argument of the function as follows:

      argTypeInfo = GIRepository.ArgInfo.getType argInfo
      tag = GIRepository.TypeInfo.get_tag argTypeInfo

      Conversion from tag is as follows:

      if direction is IN or INOUT:

        name = GIRepository.BaseInfo.getName

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    <name>
        ARRAY     --->    <name>
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    <raise Error "not expected">
        BOOLEAN   --->    <name>
        CHAR      --->    <name>
        UCHAR     --->    <name>
        INT       --->    <name>
        UINT      --->    <name>
        SHORT     --->    <name>
        USHORT    --->    <name>
        LONG      --->    <name>
        ULONG     --->    <name>
        INT8      --->    <name>
        UINT8     --->    <name>
        INT16     --->    <name>
        UINT16    --->    <name>
        INT32     --->    <name>
        UINT32    --->    <name>
        INT64     --->    <name>
        UINT64    --->    <name>
        FLOAT     --->    <name>
        DOUBLE    --->    <name>
        SSIZE     --->    <name>
        SIZE      --->    <name>
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    <name>
        UNICHAR   --->    <name>
        INTERFACE --->    <name>

      otherwise (direction is OUT):

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    NONE
        ARRAY     --->    <argArrayVal>
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    <raise Error "not expected">
        BOOLEAN   --->    GBool.null
        CHAR      --->    GChar.null
        UCHAR     --->    GUChar.null
        INT       --->    GInt.null
        UINT      --->    GUInt.null
        SHORT     --->    GShort.null
        USHORT    --->    GUShort.null
        LONG      --->    GLong.null
        ULONG     --->    GULong.null
        INT8      --->    GInt8.null
        UINT8     --->    GUInt8.null
        INT16     --->    GInt16.null
        UINT16    --->    GUInt16.null
        INT32     --->    GInt32.null
        UINT32    --->    GUInt32.null
        INT64     --->    GInt64.null
        UINT64    --->    GUInt64.null
        FLOAT     --->    GFloat.null
        DOUBLE    --->    GDouble.null
        SSIZE     --->    GSSize.null
        SIZE      --->    GSize.null
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    NONE
        UNICHAR   --->    GChar.null
        INTERFACE --->    <argInterfaceVal>


  argArrayVal
    is as follows:

      isPointer = GIRepository.TypeInfo.isPointer argTypeInfo
      arrayLengthParamIdx = GIRepository.TypeInfo.getArrayLength argTypeInfo
      arraySize = GIRepository.TypeInfo.getArrayFixedSize argTypeInfo

        isPointer      arrayLengthParamIdx     arraySize    | argArrayVal
      ======================================================+=========================
        false          _                       <n>, n <> ~1 | <n>
      ------------------------------------------------------+-------------------------
        false          <i>, i <> ~1            ~1           | <convertToInt(i, outParamName[N~[i]])>
      ------------------------------------------------------+-------------------------
        false          ~1                      ~1           | <raise Error "cannot determine array length">
      ------------------------------------------------------+-------------------------
        true           _                       _            | NONE
      ------------------------------------------------------+-------------------------


  argInterfaceVal
    is defined according to the interface type as follows:

      argInterfaceTypeInfo = GIRepository.TypeInfo.getInterface argTypeInfo
      argInfoType = GIRepository.InfoType.getType argInterfaceTypeInfo

      NONE
        if argInfoType is OBJECT _.


      <raise Error>  # for now
        if argInfoType is INTERFACE _.


      <argStructVal>
        if argInfoType is STRUCT _, where

          argStructVal is defined as follows:

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer    | argStructVal
            ===============+===================================
              false        | ()
            ---------------+-----------------------------------
              true         | NONE
            ---------------+-----------------------------------


      <InterfaceNamespace><InterfaceName>.flags []
        if argInfoType is FLAGS _.


      <InterfaceNamespace><InterfaceName>.null
        if argInfoType is ENUM _.


      <raise Error "not supported">  # ignore other cases for now
        otherwise.


  errorDomain[e] is the <e>th error domain.
    Currently GIR support for error domain annotations is not yet implemented
    and the gtk-doc annotations do not provide the annotations.  For now
    <E>, the number of error domains, is always 0.



==Low-Level Functions==

===Poly/ML===

For J non-VOID parameters, LowLevelFunction has the form:


  val <functionName>_ =
    call
      (getSymbol "<function_symbol>")
      (<selfConv>
        &&> <paramConv[1]>
        &&> ...
        &&> <paramConv[J]>
       [&&> <paramConvErr>]
        --> <retConv>);

    if J > 0 and anySet (FunctionFlags, IS_METHOD)


  val <functionName>_ =
    call
      (getSymbol "<function_symbol>")
      (<paramConv[1]>
        &&> ...
        &&> <paramConv[J]>
       [&&> <paramConvErr>]
        --> <retConv>);

    if J > 0 and not anySet (FunctionFlags, IS_METHOD)


  val <functionName>_ =
    call
      (getSymbol "<function_symbol>")
      (<selfConv> [&&> <paramConvErr>] --> <retConv>);

    if J = 0 and anySet (FunctionFlags, IS_METHOD)


  val <functionName>_ =
    call
      (getSymbol "<function_symbol>")
      (<paramConvErr> --> <retConv>);

    if J = 0 and not anySet (FunctionFlags, IS_METHOD)
             and anySet (FunctionFlags, THROWS)


  val <functionName>_ =
    call
      (getSymbol "<function_symbol>")
      (cVoid --> <retConv>);

    if J = 0 and not anySet (FunctionFlags, IS_METHOD)
             and not anySet (FunctionFlags, THROWS)


where


  [<e>]
    is
      <e>
        if anySet (FunctionFlags, THROWS) and

      <empty>
        otherwise


  selfConv
    is <parInterfaceConv> where the interface is the enclosing entity.
    Note that the GIR type tag of the enclosing entity must be INTERFACE: no
    other type tag is an entity that has functions.


  paramConvErr
    is GError.PolyML.cOutPtr


  paramConv[j]
    is the Poly/ML C conversion for the <j>th non-VOID parameter of the
    function, given by argInfo, defined according to the GIR type tag as
    follows:

      argTypeInfo = GIRepository.ArgInfo.getType argInfo
      tag = GIRepository.TypeInfo.get_tag argTypeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    <parUtf8Conv>
        GTYPE     --->    <raise Error "not supported">
        ARRAY     --->    <parArrayConv>
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    <raise Error "not expected">
        BOOLEAN   --->    <parScalarConv(GBool.PolyML)>
        CHAR      --->    <parScalarConv(GChar.PolyML)>
        UCHAR     --->    <parScalarConv(GUChar.PolyML)>
        INT       --->    <parScalarConv(GInt.PolyML)>
        UINT      --->    <parScalarConv(GUInt.PolyML)>
        SHORT     --->    <parScalarConv(GShort.PolyML)>
        USHORT    --->    <parScalarConv(GUShort.PolyML)>
        LONG      --->    <parScalarConv(GLong.PolyML)>
        ULONG     --->    <parScalarConv(GULong.PolyML)>
        INT8      --->    <parScalarConv(GInt8.PolyML)>
        UINT8     --->    <parScalarConv(GUInt8.PolyML)>
        INT16     --->    <parScalarConv(GInt16.PolyML)>
        UINT16    --->    <parScalarConv(GUInt16.PolyML)>
        INT32     --->    <parScalarConv(GInt32.PolyML)>
        UINT32    --->    <parScalarConv(GUInt32.PolyML)>
        INT64     --->    <parScalarConv(GInt64.PolyML)>
        UINT64    --->    <parScalarConv(GUInt64.PolyML)>
        FLOAT     --->    <parScalarConv(GFloat.PolyML)>
        DOUBLE    --->    <parScalarConv(GDouble.PolyML)>
        SSIZE     --->    <parScalarConv(GSSize.PolyML)>
        SIZE      --->    <parScalarConv(GSize.PolyML)>
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    <parUtf8Conv>
        UNICHAR   --->    <parScalarConv(GChar.PolyML)>
        INTERFACE --->    <parInterfaceConv>


  parScalarConv(A)
    is defined as follows:

        direction = GIRepository.ArgInfo.getDirection argInfo

          direction       | parScalarConv(A)
        ==================+===========================
          IN              | <A>.cVal
        ------------------+---------------------------
          OUT             | <A>.cRef
        ------------------+---------------------------
          INOUT           | <A>.cRef
        ------------------+---------------------------


  parUtf8Conv
    is defined as follows:

        direction = GIRepository.ArgInfo.getDirection argInfo

        isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

          direction       isPointer    | parUtf8Conv
        ===============================+===================
                          false        | <raise Error nonPtrForUtf8InPar>
          IN            ---------------+-------------------
                          true         | <A>.cIn<Opt>Ptr
        -------------------------------+-------------------
                          false        | <raise Error nonPtrForUtf8OutPar>
          OUT           ---------------+-------------------
                          true         | <A>.cOut<Opt>Ref
        -------------------------------+-------------------
                          false        | <A>.cIn<Opt>Ptr
          INOUT         ---------------+-------------------
                          true         | <A>.cInOut<Opt>Ref
        -------------------------------+-------------------

      A is Utf8.PolyML

      Opt is defined as follows:

        mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo

          mayBeNull       | Opt
        ==================+===================
          false           | <empty>
        ------------------+-------------------
          true            | Opt
        ------------------+-------------------


  parArrayConv
    is defined as follows:

        direction = GIRepository.ArgInfo.getDirection argInfo

        isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

          direction       isPointer    | parArrayConv
        ===============================+===================
                          false        | <raise Error nonPtrForArrayInPar>
          IN            ---------------+-------------------
                          true         | <A>.cIn<Opt>Ptr
        -------------------------------+-------------------
                          false        | <A>.cInPtr
          OUT           ---------------+-------------------
                          true         | <A>.cOut<Opt>Ref
        -------------------------------+-------------------
                          false        | <A>.cIn<Opt>Ptr
          INOUT         ---------------+-------------------
                          true         | <A>.cInOut<Opt>Ref
        -------------------------------+-------------------

      A is <StructId>.PolyML

      Opt is defined as follows:

        mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo

          mayBeNull       | Opt
        ==================+===================
          false           | <empty>
        ------------------+-------------------
          true            | Opt
        ------------------+-------------------


  parInterfaceConv
    is defined according to the interface type as follows:

      argInterfaceTypeInfo = GIRepository.TypeInfo.getInterface argTypeInfo
      argInfoType = GIRepository.InfoType.getType argInterfaceTypeInfo

      <parInterfaceObjectConv>
        if argInfoType is OBJECT argObjectInfo, where

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <raise Error nonPtrForObject>
            ------------------+-----------------------------------
              true            | <>
            ------------------+-----------------------------------

          parInterfaceObjectConv is defined as follows:

            direction = GIRepository.ArgInfo.getDirection argInfo

              direction       | parInterfaceObjectConv
            ==================+===========================
              IN              | <A>.c<Opt>Ptr
            ------------------+---------------------------
              OUT             | <A>.cOut<Opt>Ref
            ------------------+---------------------------
              INOUT           | <A>.cInOut<Opt>Ref
            ------------------+---------------------------

          A is <ObjectNamespace><ObjectName>Class.PolyML

          ObjectName = GIRepository.BaseInfo.getName argObjectInfo
          ObjectNamespace = GIRepository.BaseInfo.getNamespace argObjectInfo

          Opt is defined as follows:

            mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo

              mayBeNull       | Opt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------


      <raise Error>  # for now
        if argInfoType is INTERFACE _.


      <parInterfaceStructConv>
        if argInfoType is STRUCT argStructInfo, where

          parInterfaceStructConv is defined as follows:

            direction = GIRepository.ArgInfo.getDirection argInfo

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              direction       isPointer    | parInterfaceStructConv
            ===============================+===================
                              false        | <raise Error nonPtrForStructInPar>
              IN            ---------------+-------------------
                              true         | <A>.c<Opt>Ptr
            -------------------------------+-------------------
                              false        | <A>.cPtr
              OUT           ---------------+-------------------
                              true         | <A>.cOut<Opt>Ref
            -------------------------------+-------------------
                              false        | <A>.cPtr
              INOUT         ---------------+-------------------
                              true         | <A>.cInOut<Opt>Ref
            -------------------------------+-------------------

          A is <InterfaceNamespace><InterfaceName>Record.PolyML

          InterfaceName = GIRepository.BaseInfo.getName argStructInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace argStructInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          Opt is defined as follows:

            mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo

              mayBeNull       | Opt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------

        It is necessary to handle the case when `isPointer` is false explicitly.
        When a STRUCT is not passed as a pointer, but a reference to a value, the
        'standard' scheme would require a value representation of a STRUCT in
        SML, like e.g. an INT32.  This is not possible for a STRUCT in general
        as some are opaque, e.g. GtkTextIter, though it could well be useful for
        a non-opaque STRUCT, e.g. GtkAccelKey.  Therefore, a reference to a STRUCT
        value is treated as a pointer.


      <parInterfaceFlagsEnumConv>
        if argInfoType is FLAGS argFlagsEnumInfo | ENUM argFlagsEnumInfo.

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <>
            ------------------+-----------------------------------
              true            | <raise Error ptrForFlagsEnum>
            ------------------+-----------------------------------

          parInterfaceFlagsEnumConv is defined as follows:

            direction = GIRepository.ArgInfo.getDirection argInfo

              direction       | parInterfaceFlagsEnumConv
            ==================+===========================
              IN              | <A>.cVal
            ------------------+---------------------------
              OUT             | <A>.cRef
            ------------------+---------------------------
              INOUT           | <A>.cRef
            ------------------+---------------------------

          A is defined as follows:

            <InterfaceNamespace><InterfaceName>.PolyML
              if (<InterfaceNamespace>, SOME <InterfaceName>) is not equal
              to (<FunctionNamespace>, <optContainerName>), where

            PolyML
              otherwise

          InterfaceName = GIRepository.BaseInfo.getName argFlagsEnumInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace argFlagsEnumInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>


      <raise Error "not supported">
        if argInfoType is CALLBACK _.

        Note that CALLBACK can have
          mayBeNull = true
          isPointer = false
        i.e. isOpt implies isPointer does not necessarily hold.


      <raise Error "not supported">  # ignore other cases for now
        otherwise.


  retConv
    is the Poly/ML C conversion for the return value of the function, defined
    according to the GIR type tag as follows:

      retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
      tag = GIRepository.TypeInfo.get_tag retTypeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    <retUtf8Conv>
        GTYPE     --->    <raise Error "not supported">
        ARRAY     --->    <raise Error "not supported">
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    cVoid
        BOOLEAN   --->    <retScalarConv(GBool.PolyML)>
        CHAR      --->    <retScalarConv(GChar.PolyML)>
        UCHAR     --->    <retScalarConv(GUChar.PolyML)>
        INT       --->    <retScalarConv(GInt.PolyML)>
        UINT      --->    <retScalarConv(GUInt.PolyML)>
        SHORT     --->    <retScalarConv(GShort.PolyML)>
        USHORT    --->    <retScalarConv(GUShort.PolyML)>
        LONG      --->    <retScalarConv(GLong.PolyML)>
        ULONG     --->    <retScalarConv(GULong.PolyML)>
        INT8      --->    <retScalarConv(GInt8.PolyML)>
        UINT8     --->    <retScalarConv(GUInt8.PolyML)>
        INT16     --->    <retScalarConv(GInt16.PolyML)>
        UINT16    --->    <retScalarConv(GUInt16.PolyML)>
        INT32     --->    <retScalarConv(GInt32.PolyML)>
        UINT32    --->    <retScalarConv(GUInt32.PolyML)>
        INT64     --->    <retScalarConv(GInt64.PolyML)>
        UINT64    --->    <retScalarConv(GUInt64.PolyML)>
        FLOAT     --->    <retScalarConv(GFloat.PolyML)>
        DOUBLE    --->    <retScalarConv(GDouble.PolyML)>
        SSIZE     --->    <retScalarConv(GSSize.PolyML)>
        SIZE      --->    <retScalarConv(GSize.PolyML)>
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    <retUtf8Conv>
        UNICHAR   --->    <retScalarConv(GChar.PolyML)>
        INTERFACE --->    <retInterfaceConv>


  retScalarConv(A)
    is defined as follows:

          | retScalarConv(A)
        ==+===========================
          | <A>.cVal
        --+---------------------------


  retUtf8Conv
    is defined as follows:

      retUtf8Conv is <A>.cOut<Opt>Ptr

      A is Utf8.PolyML

      Opt is defined as follows:

        mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

          mayReturnNull   | Opt
        ==================+===================
          false           | <empty>
        ------------------+-------------------
          true            | Opt
        ------------------+-------------------


  retArrayConv
    is defined as follows:

        retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo

      retArrayConv is <A>.cOut<Opt>Ptr

      A is <ArrayStructId(retTypeInfo)>.PolyML

      Opt is defined as follows:

        mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

          mayReturnNull   | Opt
        ==================+===================
          false           | <empty>
        ------------------+-------------------
          true            | Opt
        ------------------+-------------------


  retInterfaceConv
    is defined according to the interface type as follows:

      retInterfaceTypeInfo = GIRepository.TypeInfo.getInterface retTypeInfo
      retInfoType = GIRepository.InfoType.getType retInterfaceTypeInfo

      <retInterfaceObjectConv>
        if retInfoType is OBJECT retObjectInfo, where

            isPointer = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <raise Error nonPtrForObject>
            ------------------+-----------------------------------
              true            | <>
            ------------------+-----------------------------------

          retInterfaceObjectConv is <A>.c<Opt>Ptr

          A is <ObjectNamespace><ObjectName>Class.PolyML

          ObjectName = GIRepository.BaseInfo.getName retObjectInfo
          ObjectNamespace = GIRepository.BaseInfo.getNamespace retObjectInfo

          Opt is defined as follows:

            mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

              mayReturnNull   | Opt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------


      <raise Error>  # for now
        if retInfoType is INTERFACE _.


      <retInterfaceStructConv>
        if retInfoType is STRUCT retStructInfo, where

          retInterfaceStructConv is defined as follows:

            isPointer = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer       | retInterfaceStructConv
            ==================+===================================
              false           | <raise Error nonPtrForStructRet>
            ------------------+-----------------------------------
              true            | <A>.c<Opt>Ptr
            ------------------+-----------------------------------

          A is <InterfaceNamespace><InterfaceName>Record.PolyML

          InterfaceName = GIRepository.BaseInfo.getName retStructInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace retStructInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          Opt is defined as follows:

            mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

              mayReturnNull   | Opt
            ==================+===================
              false           | <empty>
            ------------------+-------------------
              true            | Opt
            ------------------+-------------------

        It is necessary to handle the case when `isPointer` is false explicitly.
        When a STRUCT is not passed as a pointer, but a reference to a value, the
        'standard' scheme would require a value representation of a STRUCT in
        SML, like e.g. an INT32.  This is not possible for a STRUCT in general
        as some are opaque, e.g. GtkTextIter, though it could well be useful for
        a non-opaque STRUCT, e.g. GtkAccelKey.  Therefore, a reference to a STRUCT
        value is treated as a pointer.


      <retInterfaceFlagsEnumConv>
        if retInfoType is FLAGS retFlagsEnumInfo | ENUM retFlagsEnumInfo.

            isPointer = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <>
            ------------------+-----------------------------------
              true            | <raise Error ptrForFlagsEnum>
            ------------------+-----------------------------------

          retInterfaceFlagsEnumConv is <A>.cVal

          A is defined as follows:

            <InterfaceNamespace><InterfaceName>.PolyML
              if (<InterfaceNamespace>, SOME <InterfaceName>) is not equal
              to (<FunctionNamespace>, <optContainerName>), where

            PolyML
              otherwise

          InterfaceName = GIRepository.BaseInfo.getName retFlagsEnumInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace retFlagsEnumInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>


      <raise Error "not supported">
        if retInfoType is CALLBACK _.

        Note that CALLBACK can have
          mayBeNull = true
          isPointer = false
        i.e. isOpt implies isPointer does not necessarily hold.


      <raise Error "not supported">  # ignore other cases for now
        otherwise.



===MLton===

For J non-VOID parameters, LowLevelFunction has the form:


  val <functionName>_ =
    fn <x[1]> & ... & <x[J + 1]> [& <x[J + 2]>] =>
      (_import "<function_symbol>"
        : <selfType>
           * <parType[1]>
           * ...
           * <parType[J]>
          [* <parTypeErr>]
           -> <retType>;)
      (<x[1]>, ..., <x[J + 1]>[, <x[J + 2]>])

    if J > 0 and anySet (FunctionFlags, IS_METHOD)


  val <functionName>_ =
    fn <x[1]> & ... & <x[J]> [& <x[J + 1]>] =>
      (_import "<function_symbol>"
        : <parType[1]>
           * ...
           * <parType[J]>
          [* <parTypeErr>]
           -> <retType>;)
      (<x[1]>, ..., <x[J]>[, <x[J + 1]>])

    if J > 0 and not anySet (FunctionFlags, IS_METHOD)


  val <functionName>_ =
    fn x1 & x2 =>
      (_import "<function_symbol>" : <selfType> * <parTypeErr> -> <retType>;)
      (x1, x2)

    if J = 0 and anySet (FunctionFlags, IS_METHOD)
             and anySet (FunctionFlags, THROWS)


  val <functionName>_ =
     _import "<function_symbol>" : <selfType> -> <retType>;

    if J = 0 and anySet (FunctionFlags, IS_METHOD)
             and not anySet (FunctionFlags, THROWS)


  val <functionName>_ =
    _import "<function_symbol>" : <parTypeErr> -> <retType>;

    if J = 0 and not anySet (FunctionFlags, IS_METHOD)
             and anySet (FunctionFlags, THROWS)


  val <functionName>_ =
    _import "<function_symbol>" : unit -> <retType>;

    if J = 0 and not anySet (FunctionFlags, IS_METHOD)
             and not anySet (FunctionFlags, THROWS)


Note that this does not capture the work-around required to flatten out string
and string vector SML parameter types which introduce tuples of x<N> function
parameters that are flattened out e.g.

  fn (x1, x2) & (x3, x4, x5) & ... =>
    (_import ...)
    (x1, x2, x3, x4, x5, ...)


where


  [<e>]
    is
      <e>
        if anySet (FunctionFlags, THROWS) and

      <empty>
        otherwise


  selfType
    is <parInterfaceType> where the interface is the enclosing entity.
    Note that the GIR type tag of the enclosing entity must be INTERFACE: no
    other type tag is an entity that has functions.


  x[j] is the identifier x<j>


  parTypeErr
    is GError.FFI.outptr


  parType[j]
    is the SML type for the <j>th non-VOID parameter of the function,
    given by argInfo, defined according to the GIR type tag as follows:

      argTypeInfo = GIRepository.ArgInfo.getType argInfo
      tag = GIRepository.TypeInfo.get_tag argTypeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    <parUtf8Type>
        GTYPE     --->    <raise Error "not supported">
        ARRAY     --->    <parArrayType>
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    <raise Error "not expected">
        BOOLEAN   --->    <parScalarType(GBool.FFI)>
        CHAR      --->    <parScalarType(GChar.FFI)>
        UCHAR     --->    <parScalarType(GUChar.FFI)>
        INT       --->    <parScalarType(GInt.FFI)>
        UINT      --->    <parScalarType(GUInt.FFI)>
        SHORT     --->    <parScalarType(GShort.FFI)>
        USHORT    --->    <parScalarType(GUShort.FFI)>
        LONG      --->    <parScalarType(GLong.FFI)>
        ULONG     --->    <parScalarType(GULong.FFI)>
        INT8      --->    <parScalarType(GInt8.FFI)>
        UINT8     --->    <parScalarType(GUInt8.FFI)>
        INT16     --->    <parScalarType(GInt16.FFI)>
        UINT16    --->    <parScalarType(GUInt16.FFI)>
        INT32     --->    <parScalarType(GInt32.FFI)>
        UINT32    --->    <parScalarType(GUInt32.FFI)>
        INT64     --->    <parScalarType(GInt64.FFI)>
        UINT64    --->    <parScalarType(GUInt64.FFI)>
        FLOAT     --->    <parScalarType(GFloat.FFI)>
        DOUBLE    --->    <parScalarType(GDouble.FFI)>
        SSIZE     --->    <parScalarType(GSSize.FFI)>
        SIZE      --->    <parScalarType(GSize.FFI)>
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    <parUtf8Type>
        UNICHAR   --->    <parScalarType(GChar.FFI)>
        INTERFACE --->    <parInterfaceType>


  parScalarType(A)
    is defined as follows:

        direction = GIRepository.ArgInfo.getDirection argInfo

          direction       | parScalarType(A)
        ==================+===========================
          IN              | <A>.val_
        ------------------+---------------------------
          OUT             | <A>.ref_
        ------------------+---------------------------
          INOUT           | <A>.ref_
        ------------------+---------------------------


  parUtf8Type
    is defined as follows:

        direction = GIRepository.ArgInfo.getDirection argInfo

        isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

          direction       isPointer    | parInterfaceStructType
        ===============================+===================
                          false        | <raise Error nonPtrForUtf8InPar>
          IN            ---------------+-------------------
                          true         | <opt> <A>.in_p
        -------------------------------+-------------------
                          false        | <raise Error nonPtrForUtf8OutPar>
          OUT           ---------------+-------------------
                          true         | (<A>.opt, <opt>) <A>.r
        -------------------------------+-------------------
                          false        | <A>.non_opt <A>.p
          INOUT         ---------------+-------------------
                          true         | (<opt>, <opt>) <A>.r
        -------------------------------+-------------------

      A is Utf8.FFI

      opt is defined as follows:

        mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo

          mayBeNull       | opt
        ==================+===================
          false           | <A>.non_opt
        ------------------+-------------------
          true            | <A>.opt
        ------------------+-------------------


  parArrayType
    is defined as follows:

        direction = GIRepository.ArgInfo.getDirection argInfo

        isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

          direction       isPointer    | parInterfaceStructType
        ===============================+===================
                          false        | <raise Error nonPtrForArrayInPar>
          IN            ---------------+-------------------
                          true         | <opt> <A>.in_p
        -------------------------------+-------------------
                          false        | <A>.non_opt <A>.in_p
          OUT           ---------------+-------------------
                          true         | (<A>.opt, <opt>) <A>.r
        -------------------------------+-------------------
                          false        | <opt> <A>.in_p
          INOUT         ---------------+-------------------
                          true         | (<opt>, <opt>) <A>.r
        -------------------------------+-------------------

      A is <ArrayStructId(argTypeInfo)>.FFI

      opt is defined as follows:

        mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo

          mayBeNull       | opt
        ==================+===================
          false           | <A>.non_opt
        ------------------+-------------------
          true            | <A>.opt
        ------------------+-------------------


  parInterfaceType
    is defined according to the interface type as follows:

      argInterfaceTypeInfo = GIRepository.TypeInfo.getInterface argTypeInfo
      argInfoType = GIRepository.InfoType.getType argInterfaceTypeInfo

      <parInterfaceObjectType>
        if argInfoType is OBJECT argObjectInfo, where

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <raise Error nonPtrForObject>
            ------------------+-----------------------------------
              true            | <>
            ------------------+-----------------------------------

          parInterfaceObjectType is defined as follows:

            direction   = GIRepository.ArgInfo.getDirection argInfo

              direction       | parInterfaceObjectType
            ==================+===========================
              IN              | <opt> <A>.p
            ------------------+---------------------------
              OUT             | (<A>.opt, <opt>) <A>.r
            ------------------+---------------------------
              INOUT           | (<opt>, <opt>) <A>.r
            ------------------+---------------------------

          A is <ObjectNamespace><ObjectName>Class.FFI

          ObjectName = GIRepository.BaseInfo.getName argObjectInfo
          ObjectNamespace = GIRepository.BaseInfo.getNamespace argObjectInfo

          opt is defined as follows:

            mayBeNull   = GIRepository.ArgInfo.mayBeNull argInfo

              mayBeNull       | opt
            ==================+===================
              false           | <A>.non_opt
            ------------------+-------------------
              true            | <A>.opt
            ------------------+-------------------


      <raise Error>  # for now
        if argInfoType is INTERFACE _.


      <parInterfaceStructType>
        if argInfoType is STRUCT argStructInfo, where

          parInterfaceStructType is defined as follows:

            direction = GIRepository.ArgInfo.getDirection argInfo

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              direction       isPointer    | parInterfaceStructType
            ===============================+===================
                              false        | <raise Error nonPtrForStructInPar>
              IN            ---------------+-------------------
                              true         | <opt> <A>.p
            -------------------------------+-------------------
                              false        | <A>.non_opt <A>.p
              OUT           ---------------+-------------------
                              true         | (<A>.opt, <opt>) <A>.r
            -------------------------------+-------------------
                              false        | <A>.non_opt <A>.p
              INOUT         ---------------+-------------------
                              true         | (<opt>, <opt>) <A>.r
            -------------------------------+-------------------

          A is <InterfaceNamespace><InterfaceName>Record.FFI

          InterfaceName = GIRepository.BaseInfo.getName argStructInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace argStructInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          opt is defined as follows:

            mayBeNull = GIRepository.ArgInfo.mayBeNull argInfo

              mayBeNull       | opt
            ==================+===================
              false           | <A>.non_opt
            ------------------+-------------------
              true            | <A>.opt
            ------------------+-------------------

        It is necessary to handle the case when `isPointer` is false explicitly.
        When a STRUCT is not passed as a pointer, but a reference to a value, the
        'standard' scheme would require a value representation of a STRUCT in
        SML, like e.g. an INT32.  This is not possible for a STRUCT in general
        as some are opaque, e.g. GtkTextIter, though it could well be useful for
        a non-opaque STRUCT, e.g. GtkAccelKey.  Therefore, a reference to a STRUCT
        value is treated as a pointer.


      <parInterfaceFlagsEnumType>
        if argInfoType is FLAGS argFlagsEnumInfo | ENUM argFlagsEnumInfo.

            isPointer = GIRepository.TypeInfo.isPointer argTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <>
            ------------------+-----------------------------------
              true            | <raise Error ptrForFlagsEnum>
            ------------------+-----------------------------------

          parInterfaceFlagsEnumType is defined as follows:

            direction = GIRepository.ArgInfo.getDirection argInfo

              direction       | parInterfaceFlagsEnumType
            ==================+===========================
              IN              | <A>.val_
            ------------------+---------------------------
              OUT             | <A>.ref_
            ------------------+---------------------------
              INOUT           | <A>.ref_
            ------------------+---------------------------

          A is defined as follows:

            <InterfaceNamespace><InterfaceName>.FFI
              if (<InterfaceNamespace>, SOME <InterfaceName>) is not equal
              to (<FunctionNamespace>, <optContainerName>), where

            FFI
              otherwise

          InterfaceName = GIRepository.BaseInfo.getName argFlagsEnumInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace argFlagsEnumInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>


      <raise Error "not supported">
        if argInfoType is CALLBACK _.

        Note that CALLBACK can have
          mayBeNull = true
          isPointer = false
        i.e. isOpt implies isPointer does not necessarily hold.


      <raise Error "not supported">  # ignore other cases for now
        otherwise.


  retType
    is the SML type for the return value of the function, defined
    according to the GIR type tag as follows:

      retTypeInfo = GIRepository.CallableInfo.getReturnType functionInfo
      tag = GIRepository.TypeInfo.get_tag retTypeInfo

      Conversion from tag is as follows:

        ERROR     --->    <raise Error "not expected">
        FILENAME  --->    <retUtf8Type>
        GTYPE     --->    <raise Error "not supported">
        ARRAY     --->    <retArrayType>
        GLIST     --->    <raise Error "not supported">
        GSLIST    --->    <raise Error "not supported">
        GHASH     --->    <raise Error "not supported">
        VOID      --->    unit
        BOOLEAN   --->    <retScalarType(GBool.FFI)>
        CHAR      --->    <retScalarType(GChar.FFI)>
        UCHAR     --->    <retScalarType(GUChar.FFI)>
        INT       --->    <retScalarType(GInt.FFI)>
        UINT      --->    <retScalarType(GUInt.FFI)>
        SHORT     --->    <retScalarType(GShort.FFI)>
        USHORT    --->    <retScalarType(GUShort.FFI)>
        LONG      --->    <retScalarType(GLong.FFI)>
        ULONG     --->    <retScalarType(GULong.FFI)>
        INT8      --->    <retScalarType(GInt8.FFI)>
        UINT8     --->    <retScalarType(GUInt8.FFI)>
        INT16     --->    <retScalarType(GInt16.FFI)>
        UINT16    --->    <retScalarType(GUInt16.FFI)>
        INT32     --->    <retScalarType(GInt32.FFI)>
        UINT32    --->    <retScalarType(GUInt32.FFI)>
        INT64     --->    <retScalarType(GInt64.FFI)>
        UINT64    --->    <retScalarType(GUInt64.FFI)>
        FLOAT     --->    <retScalarType(GFloat.FFI)>
        DOUBLE    --->    <retScalarType(GDouble.FFI)>
        SSIZE     --->    <retScalarType(GSSize.FFI)>
        SIZE      --->    <retScalarType(GSize.FFI)>
        OFFSET    --->    <raise Error "not supported">
        INTPTR    --->    <raise Error "not supported">
        UINTPTR   --->    <raise Error "not supported">
        UTF8      --->    <retUtf8Type>
        UNICHAR   --->    <retScalarType(GChar.FFI)>
        INTERFACE --->    <retInterfaceType>


  retScalarType(A)
    is defined as follows:

          | retScalarType(A)
        ==+===========================
          | <A>.val_
        --+---------------------------


  retUtf8Type
    is defined as follows:

      retUtf8Type is <opt> <A>.out_p

      A is Utf8.FFI

      opt is defined as follows:

        mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

          mayReturnNull   | opt
        ==================+===================
          false           | <A>.non_opt
        ------------------+-------------------
          true            | <A>.opt
        ------------------+-------------------


  retArrayType
    is defined as follows:

        mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo
        retTypeInfo   = GIRepository.CallableInfo.getReturnType functionInfo

      retArrayType is <opt> <A>.out_p

      A is ArrayStructId(retTypeInfo).FFI

      opt is defined as follows:

          mayReturnNull   | opt
        ==================+===================
          false           | <A>.non_opt
        ------------------+-------------------
          true            | <A>.opt
        ------------------+-------------------


  retInterfaceType
    is defined according to the interface type as follows:

      retInterfaceTypeInfo = GIRepository.TypeInfo.getInterface retTypeInfo
      retInfoType = GIRepository.InfoType.getType retInterfaceTypeInfo

      <retInterfaceObjectType>
        if retInfoType is OBJECT retObjectInfo, where

            isPointer = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <raise Error nonPtrForObject>
            ------------------+-----------------------------------
              true            | <>
            ------------------+-----------------------------------

          retInterfaceObjectType is <opt> <A>.out_p

          A is <ObjectNamespace><ObjectName>Class.FFI

          ObjectName = GIRepository.BaseInfo.getName retObjectInfo
          ObjectNamespace = GIRepository.BaseInfo.getNamespace retObjectInfo

          opt is defined as follows:

            mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

              mayReturnNull   | opt
            ==================+===================
              false           | <A>.non_opt
            ------------------+-------------------
              true            | <A>.opt
            ------------------+-------------------


      <raise Error>  # for now
        if retInfoType is INTERFACE _.


      <retInterfaceStructType>
        if retInfoType is STRUCT retStructInfo, where

          retInterfaceStructType is defined as follows:

            isPointer = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer       | retInterfaceStructType
            ==================+===================================
              false           | <raise Error nonPtrForStructRet>
            ------------------+-----------------------------------
              true            | <opt> <A>.out_p
            ------------------+-----------------------------------

          A is <InterfaceNamespace><InterfaceName>Record.FFI

          InterfaceName = GIRepository.BaseInfo.getName retStructInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace retStructInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>

          opt is defined as follows:

            mayReturnNull = GIRepository.CallableInfo.mayReturnNull functionInfo

              mayReturnNull   | opt
            ==================+===================
              false           | <A>.non_opt
            ------------------+-------------------
              true            | <A>.opt
            ------------------+-------------------

        It is necessary to handle the case when `isPointer` is false explicitly.
        When a STRUCT is not passed as a pointer, but a reference to a value, the
        'standard' scheme would require a value representation of a STRUCT in
        SML, like e.g. an INT32.  This is not possible for a STRUCT in general
        as some are opaque, e.g. GtkTextIter, though it could well be useful for
        a non-opaque STRUCT, e.g. GtkAccelKey.  Therefore, a reference to a STRUCT
        value is treated as a pointer.


      <retInterfaceFlagsEnumType>
        if retInfoType is FLAGS retFlagsEnumInfo | ENUM retFlagsEnumInfo.

            isPointer = GIRepository.TypeInfo.isPointer retTypeInfo

              isPointer       | _
            ==================+===================================
              false           | <>
            ------------------+-----------------------------------
              true            | <raise Error ptrForFlagsEnum>
            ------------------+-----------------------------------

          retInterfaceFlagsEnumType is <A>.val_

          A is defined as follows:

            <InterfaceNamespace><InterfaceName>.FFI
              if (<InterfaceNamespace>, SOME <InterfaceName>) is not equal
              to (<FunctionNamespace>, <optContainerName>), where

            FFI
              otherwise

          InterfaceName = GIRepository.BaseInfo.getName retFlagsEnumInfo
          InterfaceNamespace = GIRepository.BaseInfo.getNamespace retFlagsEnumInfo
          InterfaceCPrefix = GIRepository.getCPrefix repo <InterfaceNamespace>


      <raise Error "not supported">
        if retInfoType is CALLBACK _.

        Note that CALLBACK can have
          mayBeNull = true
          isPointer = false
        i.e. isOpt implies isPointer does not necessarily hold.


      <raise Error "not supported">  # ignore other cases for now
        otherwise.
