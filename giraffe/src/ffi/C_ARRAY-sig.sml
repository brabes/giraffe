(* Copyright (C) 2012, 2016-2017 Phil Clayton <phil.clayton@veonix.com>
 *
 * This file is part of the Giraffe Library runtime.  For your rights to use
 * this file, see the file 'LICENCE.RUNTIME' distributed with Giraffe Library
 * or visit <http://www.giraffelibrary.org/licence-runtime.html>.
 *)

(**
 * The signature C_ARRAY specifies higher-level FFI support for C arrays
 * such as character arrays, i.e. C strings, or arrays of C strings.
 *)
signature C_ARRAY =
  sig
    (**
     * The type `t` represents a C array, for example, a C character array
     * (i.e. C string) or a C string array.
     *)
    type t

    (**
     * The type `elem` represents array element values in SML.
     *)
    type elem

    (**
     * `length t` returns the length of `t` (excluding any null terminator
     * that may be present in the internal representation).
     *)
    val length : t -> int

    (**
     * `sub t i` returns the element at (zero-based) index `i` of `t`.  It
     * raises `Subscript` if `i < 0` or `length t <= i`.  Note, therefore,
     * that `i` cannot index a null terminator if one is present in the
     * internal representation.
     *)
    val sub : t -> int -> elem

    (**
     * Conversion between SML values and C arrays.
     *
     * The type `sequence` represents array values in SML.
     *
     * When the elements of the SML sequence can represent the null terminator
     * value, `fromSequence v` returns the C array that is the longest prefix
     * of `v` not containing a null terminator.  For example, for a character
     * array, i.e. where type `sequence` is `string`, we would have:
     *
     *   toSequence (fromSequence "a\000bc") = "a"
     *   toSequence (fromSequence "\000abc") = ""
     *
     *)
    type sequence
    val fromSequence : sequence -> t
    val toSequence : t -> sequence

    (**
     * The structure C provides the underlying C array representation and
     * operations.
     *)
    structure C :
      sig
        structure Pointer : C_POINTER
        type notnull = Pointer.notnull
        type 'a p = 'a Pointer.p
        type ('a, 'b) r = ('a, 'b) Pointer.r

        structure ArrayType :
          C_ARRAY_TYPE
            where type t = sequence
            where type elem = elem
            where type notnull = notnull
            where type 'a p = 'a p
      end

    (**
     * The structure FFI provides the wrapper functions and FFI types.
     *
     * Support for particular FFI mechanisms may be provided in additional
     * structures with platform-specific names.
     *)
    structure FFI :
      sig
        type notnull = C.notnull

        (**
         * Return values
         *
         * The type `'a out_p` is the FFI type for a pointer to a C array
         * returned by a C function, either as the return value or 'exported'
         * from a reference parameter.  `unit out_p` and `notnull out_p`
         * represent an optionally-null and non-null pointer, respectively.
         *
         * Note
         *
         *   Bindings to foreign functions that return a pointer to an array
         *   _must_ apply a type constraint to ensure that the return type is
         *   either `unit out_p` or `notnull out_p`.  Failure to do this can
         *   result can result in the function's context inferring
         *   `notnull out_p`, even though a function could return a null
         *   pointer.  Furthermore, functions that return an optionally-null
         *   pointer should still be constrained to `unit out_p` as it is
         *   good practice and, otherwise, under certain circumstances,
         *   warnings will be generated by the compiler indicating that a
         *   polymorphic type has been fixed, e.g. `'a` fixed as `_a`, and a
         *   subsequent type error will occur.  However, these compiler
         *   warnings/errors are not a reliable means of detecting missing
         *   type contraints.
         *)
        type 'a out_p = 'a C.p

        (* The pointer returned by a function may not, on its own, be enough
         * to read the array, in particular, the C array may not contain any
         * information about its size.  For example, a C string may not be
         * null-terminated.
         *
         * The type `'a from_p` is the function type that returns the array
         * representation 'a from the pointer type `'b out_p`.  For example,
         * an implementation that requires the size of the array would
         * define
         *
         *   'a from_p = int -> 'a
         *
         * Alternatively, if the array size can be determined from just the
         * pointer, an implementation would define
         *
         *   'a from_p = 'a
         *
         *)
        type 'a from_p = 'a C.ArrayType.from_p

        (* An array returned by or exported from a C function is wrapped
         * according to:
         *   - whether the caller must free the C array;
         *   - the persistence of the C array.
         *
         * When a returned C array is either
         *   - static or
         *   - an allocated array that must be freed by the caller
         * the C array will be in memory for as long as necessary.  In these
         * cases, `from[Opt]Ptr d` can be used where `d`, the depth to free
         * to, would be 0 for a static array.  In other cases, keeping a
         * reference to the C array may be unreliable so either
         * `fromDup[Opt]Ptr d` should be used to duplicate the top `d` levels
         * or `copyPtr tab d` should be used to copy the whole array using
         * the tabulator `tab` and free the top `d` levels.
         *)
        type 'a tabulator = int * (int -> elem) -> 'a

        val fromPtr    : int -> notnull out_p -> t from_p
        val fromDupPtr : int -> notnull out_p -> t from_p
        val copyPtr    : 'a tabulator -> int -> notnull out_p -> 'a from_p

        val fromOptPtr    : int -> 'a out_p -> t option from_p
        val fromDupOptPtr : int -> 'a out_p -> t option from_p
        val copyOptPtr    : 'a tabulator -> int -> 'b out_p -> 'a option from_p

        (**
         * Value parameters
         *
         * The type `'a in_p` is the FFI type for a pointer to a C array
         * passed by value to a C function.  The phantom type parameter 'a
         * indicates whether the pointer is an optionally-null pointer or a
         * non-null pointer, as for type `'a out_p` above.  By specifying
         * `'a` as `notnull`, wrapper functions that derive a pointer
         * argument from a `t option` value cannot be used, ensuring that the
         * pointer is non-null.
         *
         * Note
         *
         *   The implementation of type `'a in_p` is not necessarily just a
         *   pointer because an implementation may need to pass multiple
         *   arguments that are transformed by C side interface code.
         *
         * `withPtr f arr` ...
         *
         *
         * `withDupPtr depth f arr` ...
         *
         *
         * `withOptPtr f optArr` ...
         *
         *
         * `withDupOptPtr depth f optArr` ...
         *
         *   The C function `f` must return an allocated array whose
         *   ownership, i.e. responsibility for freeing, is transferred.
         *
         *
         * Considerations
         *
         * ...
         *)
        type 'a in_p

        val withPtr    : ('a in_p -> 'r) -> t -> 'r
        val withDupPtr : int -> ('a in_p -> 'r) -> t -> (notnull out_p, 'r) pair

        val withOptPtr    : (unit in_p -> 'r) -> t option -> 'r
        val withDupOptPtr : int -> (unit in_p -> 'r) -> t option -> (unit out_p, 'r) pair

        (**
         * Reference parameters
         *
         * The type `('in, 'out) r` is the FFI type for a pointer to a
         * C array passed by reference to a C function.  The phantom type
         * parameters `'in` and `'out` indicate whether the imported and
         * exported pointer, respectively, is an optionally-null pointer or
         * a non-null pointer, as for types `'a in_p` and `'a out_p` above.
         * By specifying `'in` as `notnull`, wrapper functions that derive an
         * imported pointer value from a `t option` value cannot be used,
         * which ensures that the imported pointer is non-null.  The wrapper
         * functions return the exported pointer as type `'out p` for use
         * with the return value wrapper functions above.
         *
         * Note
         *
         *   The implementation of type `('a, 'b) r` is not necessarily
         *   just a pointer because an implementation may need to pass
         *   multiple arguments that are transformed by C side interface
         *   code.
         *
         * `withNullRef f ()` ...
         *
         *
         * `withRefPtr f arr` ...
         *
         *
         * `withRefDupPtr depth f arr` ...
         *
         *
         * `withRefOptPtr f optArr` ...
         *
         *
         * `withRefDupOptPtr depth f optArr` ...
         *
         *
         * Considerations
         *
         * For `withRefPtr f cArr` with result `(p, _)`, when `f` does not
         * update the reference, `p` is a pointer to `cArr`.  In such cases,
         * `p` should be ignored.  For some implementations, `p` may even be
         * an unreliable pointer, for example, a pointer into the SML heap.
         *)
        type ('a, 'b) r

        val withNullRef : (('a, 'b) r -> 'r) -> unit -> 'r

        val withRefPtr    : (('a, 'b) r -> 'r) -> t -> ('b out_p, 'r) pair
        val withRefDupPtr : int -> (('a, 'b) r -> 'r) -> t -> ('b out_p, 'r) pair

        val withRefOptPtr    : ((unit, 'b) r -> 'r) -> t option -> ('b out_p, 'r) pair
        val withRefDupOptPtr : int -> ((unit, 'b) r -> 'r) -> t option -> ('b out_p, 'r) pair
      end
  end
