<page xmlns="http://projectmallard.org/1.0/"
      type="topic"
      id="ug-signals">
<info>
  <title type="sort">0600</title>
  <link type="guide" xref="ug-index#sml-interface"/>
</info>
<title>Signals</title>
<p>
A signal is defined by a class or interface
and is emitted by an object (instance) when a particular event occurs.
A function is called on emission of a signal by connecting to the signal
and specifying the function as the handler.
</p>
<p>
The special structure <code><link xref="ug-special-structures#signal">Signal</link></code>
provides support for working with signals in a type safe way.
</p>

<section>
<title>Referring to signals</title>
<p>
In GObject, a signal name is string of ASCII letters and digits with words separated by a hyphen (or underscore)
where the first word starts with a letter.
The SML interface provides an abstract value for each signal.
For a signal “<var>some</var>-<var>signal</var>-<var>name</var>”
of a class or interface <code><var>Namespace</var>.<var>Type</var></code>,
the hierarchical SML name is
<code><var>Namespace</var>.<var>Type</var>.<var>someSignalName</var>Sig</code>.
</p>
<example>
<p>
For example, the signal “insert-at-cursor”
of the class <code>Gtk.TextView</code> is
<code>Gtk.TextView.insertAtCursorSig</code>
</p>
</example>
<p>
In order to provide a type-safe interface for using signals,
each signal has an SML specification constraining the instance type that emits
the signal and the type of the emitter and handler functions.
</p>
<p>
The specification of <code><var>Namespace</var>.<var>Type</var>.<var>someSignalName</var>Sig</code>
in the signature <code><var>NAMESPACE</var>_<var>TYPE</var></code>
has the form:
</p>
<code>
val <var>some</var><var>Signal</var><var>Name</var>Sig : (<var>instanceType</var>, <var>argType_e</var>, <var>argType_h</var>, <var>resType_h</var>, <var>resType_e</var>) Signal.t
</code>
<p>
where
</p>
<terms>
<item>
  <title><code><var>instanceType</var></code></title>
  <p>
    is:
  </p>
  <list>
    <item><p><code>'a class</code> for a class, which allows an instance of the class or any subclass of the class;</p></item>
    <item><p><code>t</code> for an interface;</p></item>
  </list>
</item>
<item>
  <title><code><var>argType_e</var> -> <var>resType_e</var></code></title>
  <p>
    is the type of a function that emits the signal;
  </p>
</item>
<item>
  <title><code><var>argType_h</var> -> <var>resType_h</var></code></title>
  <p>
    is the type of a function that handles the signal;
  </p>
</item>
<item>
  <title><code><var>argType_e</var></code> and <code><var>argType_h</var></code></title>
  <p>
    contain the types of the &#x2018;in&#x2019; and &#x2018;inout&#x2019; arguments,
    as a tuple if there are two or more and as <code>unit</code> if there are none;
  </p>
</item>
<item>
  <title><code><var>resType_e</var></code> and <code><var>resType_h</var></code></title>
  <p>
    contain the following types as a tuple if there are two or more and as <code>unit</code> if there are none:
  </p>
  <list>
  <item>
    <p>
      the types of the &#x2018;out&#x2019; and &#x2018;inout&#x2019; arguments, if the return type is void;
    </p>
  </item>
  <item>
    <p>
      the return type followed by the types of the &#x2018;out&#x2019; and &#x2018;inout&#x2019; arguments, if the return type is not void.
    </p>
  </item>
  </list>
</item>
</terms>
<p>
The difference between <code><var>argType_e</var></code> and <code><var>argType_h</var></code> and
between <code><var>resType_e</var></code> and <code><var>resType_h</var></code>
is in the SML types for a class or union:
<code><var>argType_e</var></code> and <code><var>resType_h</var></code> allow
an object of any subclass of the class and
a union instance to have the type of any field of the union
whereas <code><var>resType_e</var></code> and <code><var>argType_h</var></code> do not.
</p>
<example>
<p>
For example, the specification of <code>Gtk.TextView.insertAtCursorSig</code> is
</p>
<code>
val insertAtCursorSig : ('a class, string, string, unit, unit) Signal.t
</code>
</example>
<p>
As the example above shows,
neither <code><var>argType_e</var></code> nor <code><var>argType_h</var></code>
have an argument
for the instance that emits the signal.
</p>
</section>

<section>
<title>Specifying signal detail</title>

<p>
In GObject, the detail of a signal is a string whose format is specific to the signal.
The SML representation of a signal includes the detail,
which is used by both signal connection and emission functions.
The detail of a signal value is returned by the function <code>Signal.detail</code>
and is overridden by the functions <code>Signal.withDetail</code> and <code>Signal.withPropDetail</code>
which return a new signal value.
</p>
<p>
The detail of a signal <code><var>signal</var></code> is given by
</p>
<code>
Signal.detail <code><var>signal</var></code>
</code>
<p>
The detail of each signal provided in the SML interface is empty:
for a signal “<var>a</var>”
of a class or interface <code><var>Namespace</var>.<var>Type</var></code>,
<code>
Signal.detail <var>Namespace</var>.<var>Type</var>.<var>a</var>Sig
</code>
is <code>""</code>.
</p>
<p>
A signal <code><var>signal</var></code>
with the detail replaced by <code><var>detail</var></code> is given by
</p>
<code>
Signal.withDetail (<code><var>signal</var></code>, <var>detail</var>)
</code>
<p>
Specifying <code><var>detail</var></code> as <code>""</code> has the effect of removing any detail.
</p>
<p>
The detail of the signal “notify” of the class <code>GObject.Object</code> requires a property name if non-empty.
Using <code>Signal.withDetail</code> to override this detail requires the property name to be written as a string.
Instead, this detail can be overridden by specifying a property value using <code>Signal.withPropDetail</code>.
A signal <code><var>signal</var></code>
with the detail replaced by the name of a property <code><var>prop</var></code> and
with its type constrained for use only on instances with the property is given by
</p>
<code>
Signal.withPropDetail (<code><var>signal</var></code>, <var>prop</var>)
</code>
<p>
<code>Signal.withPropDetail</code> is preferable for a signal whose detail is a property name
because type checking also ensures that:
</p>
<list style="compact">
<item><p>the property exists;</p></item>
<item><p>the property is valid for the object on which the signal is defined;</p></item>
<item><p>the resulting signal cannot be used on an object that does not have the property.</p></item>
</list>
</section>

<section>
<title>Handling signals</title>

<note style="tip">
<p>
At present, there is support only for handling the emission of a signal from an instance of a class or interface.
There is no support for
</p>
<list style="compact">
<item><p>handling a signal on all instances of a class or interface, i.e. overriding the class closure</p></item>
<item><p>emission hooks</p></item>
</list>
</note>

<section>
<title>Connecting signal handlers</title>
<p>
A handler function is connected to a signal of an object (instance)
using <code>Signal.connect</code> or <code>Signal.connectAfter</code>.
The handler function is called
<em>before</em> the default handler by using <code>Signal.connect</code> and
<em>after</em> the default handler by using <code>Signal.connectAfter</code>.
</p>
<p>
For a signal “<var>a</var>”
of a class <code><var>ClassNamespace</var>.<var>Class</var></code>,
a handler function <code><var>f</var></code>
is connected to the signal on an object <code><var>obj</var></code> by
</p>
<code>
Signal.connect <var>obj</var> (<var>ClassNamespace</var>.<var>Class</var>.<var>a</var>Sig, <var>f</var>)
</code>
<p>
whose value is a handler id to allow the signal connection to be modified or checked subsequently.
</p>
<p>
For a signal “<var>a</var>”
of an interface <code><var>IfaceNamespace</var>.<var>Iface</var></code>
implemented by the class <code><var>ClassNamespace</var>.<var>Class</var></code>,
a handler function <code><var>f</var></code>
is connected to the signal on the object <code><var>obj</var></code> by
</p>
<code>
Signal.connect (<var>ClassNamespace</var>.<var>Class</var>.as<var>Iface</var> <var>obj</var>) (<var>IfaceNamespace</var>.<var>Iface</var>.<var>a</var>Sig, <var>f</var>)
</code>
<example>
<p>
For example, to handle emission of the signal “insert-at-cursor”
from the object <code>textView</code>
using the function <code>onInsert</code>, connect to the signal as follows:
</p>
<code>
val handlerId = Signal.connect textView (Gtk.TextView.insertAtCursorSig, onInsert)
</code>
<p>
<code>handlerId</code> can be used to modify this signal connection subsequently.
</p>
</example>
<p>
It is not unusual for the handler function <code><var>f</var></code> to need to refer to the object that emitted the signal, <code><var>obj</var></code>, but <code><var>argType_h</var></code> does not have an argument to pass <code><var>obj</var></code> to the handler <code><var>f</var></code>.
This is easily achieved by defining <code><var>f</var></code> to take the emitting object as the first argument and supplying the argument when connecting the handler as follows:
</p>
<code>
Signal.connect <var>obj</var> (<var>Namespace</var>.<var>Type</var>.<var>a</var>Sig, <var>f</var> <var>obj</var>)
</code>
<p>
Type checking ensures that when a handler is connected to a signal of an object,
</p>
<list style="compact">
<item><p>the handler function has the correct type for the signal;</p></item>
<item><p>the signal is valid for the object.</p></item>
</list>

</section>

<section>
<title>Blocking signal handlers</title>
<p>
A signal handler is blocked using <code>Signal.handlerBlock</code>
and unblocked using <code>Signal.handlerUnblock</code>.
(Note that blocking is cumulative so a signal handler becomes active
only once it has been unblocked as many times as it has been blocked.)
The signal handler to block or unblock is identified by the object that emits the signal and
the handler id returned when it was connected.
</p>
<example>
<p>
For example, a signal handler on <code>textView</code> identified by <code>handlerId</code>
is blocked as follows:
</p>
<code>
Signal.handlerBlock textView handlerId
</code>
<p>
and is unblocked as follows:
</p>
<code>
Signal.handlerUnblock textView handlerId
</code>
</example>
</section>

<section>
<title>Disconnecting signal handlers</title>
<p>
A signal handler is disconnected using <code>Signal.disconnect</code>.
The signal handler to disconnect is identified by the object that emits the signal and
the handler id returned when it was connected.
</p>
<example>
<p>
For example, a signal handler on <code>textView</code> identified by <code>handlerId</code>
is disconnected as follows:
</p>
<code>
Signal.disconnect textView handlerId
</code>
</example>
</section>

<section>
<title>Testing whether signal handlers are still connected</title>
<p>
<code>Signal.isConnected</code> tests whether a signal is connected.
The signal handler is identified by the object that emits the signal and
the handler id returned when it was connected.
</p>
<example>
<p>
For example, a signal handler on <code>textView</code> identified by <code>handlerId</code>
is tested as follows:
</p>
<code>
Signal.isConnected textView handlerId
</code>
</example>
</section>

</section>

<section>
<title>Emitting signals</title>
<p>
A signal is emitted on an object (instance)
using <code>Signal.emit</code>.
</p>
<p>
For a signal “<var>a</var>”
of a class <code><var>ClassNamespace</var>.<var>Class</var></code>,
the signal is emitted on an object <code><var>obj</var></code> with an argument <code><var>arg</var></code> by
</p>
<code>
Signal.emit <var>obj</var> <var>ClassNamespace</var>.<var>Class</var>.<var>a</var>Sig <var>arg</var>
</code>
<p>
whose value is the result.
</p>
<note style="tip">
<p>
Not all signals have a default handler.
If emission of a signal is not handled,
the result contains
</p>
<list style="compact">
<item><p>the default value for &#x2018;out&#x2019; arguments and the return value and</p></item>
<item><p>the before value for &#x2018;inout&#x2019; arguments.</p></item>
</list>
<p>
The default value is the value set on initialization of a <code>GValue</code>
by <code><link href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-init">g_value_init</link></code>
for the <code>GType</code> of the corresponding &#x2018;out&#x2019; argument or return value.
</p>
</note>
<p>
For a signal “<var>a</var>”
of an interface <code><var>IfaceNamespace</var>.<var>Iface</var></code>
implemented by the class <code><var>ClassNamespace</var>.<var>Class</var></code>,
the signal is emitted on an object <code><var>obj</var></code> with an argument <code><var>arg</var></code> by
</p>
<code>
Signal.emit (<var>ClassNamespace</var>.<var>Class</var>.as<var>Iface</var> <var>obj</var>) <var>IfaceNamespace</var>.<var>Iface</var>.<var>a</var>Sig <var>arg</var>
</code>
<example>
<p>
For example, to emit the signal “button-press-event”
on the object <code>button</code>
with the argument <code>e</code>, emit the signal as follows:
</p>
<code>
val res = Signal.emit button Widget.buttonPressEventSig e
</code>
</example>
<p>
Type checking ensures that when a signal is emitted on an object,
</p>
<list style="compact">
<item><p>the emit function has the correct type for the signal;</p></item>
<item><p>the signal is valid for the object.</p></item>
</list>
</section>

</page>
